// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmtp.proto

#include "mmtp.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR ApplicationMessage::ApplicationMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ApplicationMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplicationMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplicationMessageDefaultTypeInternal() {}
  union {
    ApplicationMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplicationMessageDefaultTypeInternal _ApplicationMessage_default_instance_;
PROTOBUF_CONSTEXPR ApplicationMessageHeader::ApplicationMessageHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sender_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.qosprofile_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.expires_)*/int64_t{0}
  , /*decltype(_impl_.bodysizenumbytes_)*/0u
  , /*decltype(_impl_.SubjectOrRecipient_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ApplicationMessageHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplicationMessageHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplicationMessageHeaderDefaultTypeInternal() {}
  union {
    ApplicationMessageHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplicationMessageHeaderDefaultTypeInternal _ApplicationMessageHeader_default_instance_;
PROTOBUF_CONSTEXPR Recipients::Recipients(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.recipients_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RecipientsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecipientsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecipientsDefaultTypeInternal() {}
  union {
    Recipients _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecipientsDefaultTypeInternal _Recipients_default_instance_;
PROTOBUF_CONSTEXPR MmtpMessage::MmtpMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msgtype_)*/0
  , /*decltype(_impl_.body_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct MmtpMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmtpMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmtpMessageDefaultTypeInternal() {}
  union {
    MmtpMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmtpMessageDefaultTypeInternal _MmtpMessage_default_instance_;
PROTOBUF_CONSTEXPR ProtocolMessage::ProtocolMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.protocolmsgtype_)*/0
  , /*decltype(_impl_.body_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ProtocolMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProtocolMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProtocolMessageDefaultTypeInternal() {}
  union {
    ProtocolMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProtocolMessageDefaultTypeInternal _ProtocolMessage_default_instance_;
PROTOBUF_CONSTEXPR Subscribe::Subscribe(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subjectOrDirectMessages_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SubscribeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubscribeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubscribeDefaultTypeInternal() {}
  union {
    Subscribe _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubscribeDefaultTypeInternal _Subscribe_default_instance_;
PROTOBUF_CONSTEXPR Unsubscribe::Unsubscribe(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subjectOrDirectMessages_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct UnsubscribeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnsubscribeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnsubscribeDefaultTypeInternal() {}
  union {
    Unsubscribe _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnsubscribeDefaultTypeInternal _Unsubscribe_default_instance_;
PROTOBUF_CONSTEXPR Send::Send(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.applicationmessage_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SendDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SendDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SendDefaultTypeInternal() {}
  union {
    Send _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SendDefaultTypeInternal _Send_default_instance_;
PROTOBUF_CONSTEXPR Receive::Receive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filter_)*/nullptr} {}
struct ReceiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReceiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReceiveDefaultTypeInternal() {}
  union {
    Receive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReceiveDefaultTypeInternal _Receive_default_instance_;
PROTOBUF_CONSTEXPR Filter::Filter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messageuuids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FilterDefaultTypeInternal() {}
  union {
    Filter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FilterDefaultTypeInternal _Filter_default_instance_;
PROTOBUF_CONSTEXPR Fetch::Fetch(
    ::_pbi::ConstantInitialized) {}
struct FetchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FetchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FetchDefaultTypeInternal() {}
  union {
    Fetch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FetchDefaultTypeInternal _Fetch_default_instance_;
PROTOBUF_CONSTEXPR Disconnect::Disconnect(
    ::_pbi::ConstantInitialized) {}
struct DisconnectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DisconnectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DisconnectDefaultTypeInternal() {}
  union {
    Disconnect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DisconnectDefaultTypeInternal _Disconnect_default_instance_;
PROTOBUF_CONSTEXPR Connect::Connect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ownmrn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reconnecttoken_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ConnectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectDefaultTypeInternal() {}
  union {
    Connect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectDefaultTypeInternal _Connect_default_instance_;
PROTOBUF_CONSTEXPR ResponseMessage::ResponseMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.messagemetadata_)*/{}
  , /*decltype(_impl_.applicationmessages_)*/{}
  , /*decltype(_impl_.responsetouuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reasontext_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reconnecttoken_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.response_)*/0} {}
struct ResponseMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseMessageDefaultTypeInternal() {}
  union {
    ResponseMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseMessageDefaultTypeInternal _ResponseMessage_default_instance_;
PROTOBUF_CONSTEXPR MessageMetadata::MessageMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MessageMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageMetadataDefaultTypeInternal() {}
  union {
    MessageMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageMetadataDefaultTypeInternal _MessageMetadata_default_instance_;
static ::_pb::Metadata file_level_metadata_mmtp_2eproto[15];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_mmtp_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_mmtp_2eproto = nullptr;

const uint32_t TableStruct_mmtp_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ApplicationMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ApplicationMessage, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::ApplicationMessage, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::ApplicationMessage, _impl_.signature_),
  PROTOBUF_FIELD_OFFSET(::ApplicationMessageHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ApplicationMessageHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::ApplicationMessageHeader, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::ApplicationMessageHeader, _impl_.expires_),
  PROTOBUF_FIELD_OFFSET(::ApplicationMessageHeader, _impl_.sender_),
  PROTOBUF_FIELD_OFFSET(::ApplicationMessageHeader, _impl_.qosprofile_),
  PROTOBUF_FIELD_OFFSET(::ApplicationMessageHeader, _impl_.bodysizenumbytes_),
  PROTOBUF_FIELD_OFFSET(::ApplicationMessageHeader, _impl_.SubjectOrRecipient_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Recipients, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Recipients, _impl_.recipients_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MmtpMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::MmtpMessage, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MmtpMessage, _impl_.msgtype_),
  PROTOBUF_FIELD_OFFSET(::MmtpMessage, _impl_.uuid_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::MmtpMessage, _impl_.body_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ProtocolMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::ProtocolMessage, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtocolMessage, _impl_.protocolmsgtype_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::ProtocolMessage, _impl_.body_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Subscribe, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Subscribe, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Subscribe, _impl_.subjectOrDirectMessages_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Unsubscribe, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Unsubscribe, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Unsubscribe, _impl_.subjectOrDirectMessages_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Send, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Send, _impl_.applicationmessage_),
  PROTOBUF_FIELD_OFFSET(::Receive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Receive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Receive, _impl_.filter_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Filter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Filter, _impl_.messageuuids_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Fetch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Disconnect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Connect, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Connect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Connect, _impl_.ownmrn_),
  PROTOBUF_FIELD_OFFSET(::Connect, _impl_.reconnecttoken_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ResponseMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ResponseMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ResponseMessage, _impl_.responsetouuid_),
  PROTOBUF_FIELD_OFFSET(::ResponseMessage, _impl_.response_),
  PROTOBUF_FIELD_OFFSET(::ResponseMessage, _impl_.reasontext_),
  PROTOBUF_FIELD_OFFSET(::ResponseMessage, _impl_.messagemetadata_),
  PROTOBUF_FIELD_OFFSET(::ResponseMessage, _impl_.applicationmessages_),
  PROTOBUF_FIELD_OFFSET(::ResponseMessage, _impl_.reconnecttoken_),
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MessageMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MessageMetadata, _impl_.uuid_),
  PROTOBUF_FIELD_OFFSET(::MessageMetadata, _impl_.header_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::ApplicationMessage)},
  { 9, 22, -1, sizeof(::ApplicationMessageHeader)},
  { 28, -1, -1, sizeof(::Recipients)},
  { 35, -1, -1, sizeof(::MmtpMessage)},
  { 46, -1, -1, sizeof(::ProtocolMessage)},
  { 61, -1, -1, sizeof(::Subscribe)},
  { 70, -1, -1, sizeof(::Unsubscribe)},
  { 79, -1, -1, sizeof(::Send)},
  { 86, 93, -1, sizeof(::Receive)},
  { 94, -1, -1, sizeof(::Filter)},
  { 101, -1, -1, sizeof(::Fetch)},
  { 107, -1, -1, sizeof(::Disconnect)},
  { 113, 121, -1, sizeof(::Connect)},
  { 123, 135, -1, sizeof(::ResponseMessage)},
  { 141, -1, -1, sizeof(::MessageMetadata)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_ApplicationMessage_default_instance_._instance,
  &::_ApplicationMessageHeader_default_instance_._instance,
  &::_Recipients_default_instance_._instance,
  &::_MmtpMessage_default_instance_._instance,
  &::_ProtocolMessage_default_instance_._instance,
  &::_Subscribe_default_instance_._instance,
  &::_Unsubscribe_default_instance_._instance,
  &::_Send_default_instance_._instance,
  &::_Receive_default_instance_._instance,
  &::_Filter_default_instance_._instance,
  &::_Fetch_default_instance_._instance,
  &::_Disconnect_default_instance_._instance,
  &::_Connect_default_instance_._instance,
  &::_ResponseMessage_default_instance_._instance,
  &::_MessageMetadata_default_instance_._instance,
};

const char descriptor_table_protodef_mmtp_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\nmmtp.proto\"`\n\022ApplicationMessage\022)\n\006he"
  "ader\030\001 \001(\0132\031.ApplicationMessageHeader\022\014\n"
  "\004body\030\002 \001(\014\022\021\n\tsignature\030\003 \001(\t\"\311\001\n\030Appli"
  "cationMessageHeader\022\021\n\007subject\030\001 \001(\tH\000\022!"
  "\n\nrecipients\030\002 \001(\0132\013.RecipientsH\000\022\017\n\007exp"
  "ires\030\003 \001(\003\022\016\n\006sender\030\004 \001(\t\022\027\n\nqosProfile"
  "\030\005 \001(\tH\001\210\001\001\022\030\n\020bodySizeNumBytes\030\006 \001(\rB\024\n"
  "\022SubjectOrRecipientB\r\n\013_qosProfile\" \n\nRe"
  "cipients\022\022\n\nrecipients\030\001 \003(\t\"\230\001\n\013MmtpMes"
  "sage\022\031\n\007msgType\030\001 \001(\0162\010.MsgType\022\014\n\004uuid\030"
  "\002 \001(\t\022+\n\017protocolMessage\030\003 \001(\0132\020.Protoco"
  "lMessageH\000\022+\n\017responseMessage\030\004 \001(\0132\020.Re"
  "sponseMessageH\000B\006\n\004body\"\314\002\n\017ProtocolMess"
  "age\022-\n\017protocolMsgType\030\001 \001(\0162\024.ProtocolM"
  "essageType\022&\n\020subscribeMessage\030\002 \001(\0132\n.S"
  "ubscribeH\000\022*\n\022unsubscribeMessage\030\003 \001(\0132\014"
  ".UnsubscribeH\000\022\034\n\013sendMessage\030\004 \001(\0132\005.Se"
  "ndH\000\022\"\n\016receiveMessage\030\005 \001(\0132\010.ReceiveH\000"
  "\022\036\n\014fetchMessage\030\006 \001(\0132\006.FetchH\000\022(\n\021disc"
  "onnectMessage\030\007 \001(\0132\013.DisconnectH\000\022\"\n\016co"
  "nnectMessage\030\010 \001(\0132\010.ConnectH\000B\006\n\004body\"S"
  "\n\tSubscribe\022\021\n\007subject\030\001 \001(\tH\000\022\030\n\016direct"
  "Messages\030\002 \001(\010H\000B\031\n\027subjectOrDirectMessa"
  "ges\"U\n\013Unsubscribe\022\021\n\007subject\030\001 \001(\tH\000\022\030\n"
  "\016directMessages\030\002 \001(\010H\000B\031\n\027subjectOrDire"
  "ctMessages\"7\n\004Send\022/\n\022applicationMessage"
  "\030\001 \001(\0132\023.ApplicationMessage\"2\n\007Receive\022\034"
  "\n\006filter\030\001 \001(\0132\007.FilterH\000\210\001\001B\t\n\007_filter\""
  "\036\n\006Filter\022\024\n\014messageUuids\030\001 \003(\t\"\007\n\005Fetch"
  "\"\014\n\nDisconnect\"Y\n\007Connect\022\023\n\006ownMrn\030\001 \001("
  "\tH\000\210\001\001\022\033\n\016reconnectToken\030\002 \001(\tH\001\210\001\001B\t\n\007_"
  "ownMrnB\021\n\017_reconnectToken\"\377\001\n\017ResponseMe"
  "ssage\022\026\n\016responseToUuid\030\001 \001(\t\022\037\n\010respons"
  "e\030\002 \001(\0162\r.ResponseEnum\022\027\n\nreasonText\030\003 \001"
  "(\tH\000\210\001\001\022)\n\017messageMetadata\030\004 \003(\0132\020.Messa"
  "geMetadata\0220\n\023applicationMessages\030\005 \003(\0132"
  "\023.ApplicationMessage\022\033\n\016reconnectToken\030\006"
  " \001(\tH\001\210\001\001B\r\n\013_reasonTextB\021\n\017_reconnectTo"
  "ken\"J\n\017MessageMetadata\022\014\n\004uuid\030\001 \001(\t\022)\n\006"
  "header\030\002 \001(\0132\031.ApplicationMessageHeader*"
  "N\n\007MsgType\022\027\n\023UNSPECIFIED_MESSAGE\020\000\022\024\n\020P"
  "ROTOCOL_MESSAGE\020\001\022\024\n\020RESPONSE_MESSAGE\020\002*"
  "\275\001\n\023ProtocolMessageType\022\017\n\013UNSPECIFIED\020\000"
  "\022\025\n\021SUBSCRIBE_MESSAGE\020\001\022\027\n\023UNSUBSCRIBE_M"
  "ESSAGE\020\002\022\020\n\014SEND_MESSAGE\020\003\022\023\n\017RECEIVE_ME"
  "SSAGE\020\004\022\021\n\rFETCH_MESSAGE\020\005\022\026\n\022DISCONNECT"
  "_MESSAGE\020\006\022\023\n\017CONNECT_MESSAGE\020\007*=\n\014Respo"
  "nseEnum\022\030\n\024UNSPECIFIED_RESPONSE\020\000\022\010\n\004GOO"
  "D\020\001\022\t\n\005ERROR\020\002B\020Z\016generated/mmtpb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_mmtp_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_mmtp_2eproto = {
    false, false, 1960, descriptor_table_protodef_mmtp_2eproto,
    "mmtp.proto",
    &descriptor_table_mmtp_2eproto_once, nullptr, 0, 15,
    schemas, file_default_instances, TableStruct_mmtp_2eproto::offsets,
    file_level_metadata_mmtp_2eproto, file_level_enum_descriptors_mmtp_2eproto,
    file_level_service_descriptors_mmtp_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_mmtp_2eproto_getter() {
  return &descriptor_table_mmtp_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_mmtp_2eproto(&descriptor_table_mmtp_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mmtp_2eproto);
  return file_level_enum_descriptors_mmtp_2eproto[0];
}
bool MsgType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProtocolMessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mmtp_2eproto);
  return file_level_enum_descriptors_mmtp_2eproto[1];
}
bool ProtocolMessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseEnum_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mmtp_2eproto);
  return file_level_enum_descriptors_mmtp_2eproto[2];
}
bool ResponseEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class ApplicationMessage::_Internal {
 public:
  static const ::ApplicationMessageHeader& header(const ApplicationMessage* msg);
};

const ::ApplicationMessageHeader&
ApplicationMessage::_Internal::header(const ApplicationMessage* msg) {
  return *msg->_impl_.header_;
}
ApplicationMessage::ApplicationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ApplicationMessage)
}
ApplicationMessage::ApplicationMessage(const ApplicationMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplicationMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.body_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_body().empty()) {
    _this->_impl_.body_.Set(from._internal_body(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_signature().empty()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::ApplicationMessageHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:ApplicationMessage)
}

inline void ApplicationMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.body_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApplicationMessage::~ApplicationMessage() {
  // @@protoc_insertion_point(destructor:ApplicationMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplicationMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.body_.Destroy();
  _impl_.signature_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void ApplicationMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplicationMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ApplicationMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.body_.ClearToEmpty();
  _impl_.signature_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplicationMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .ApplicationMessageHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string signature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ApplicationMessage.signature"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplicationMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ApplicationMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .ApplicationMessageHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // bytes body = 2;
  if (!this->_internal_body().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_body(), target);
  }

  // string signature = 3;
  if (!this->_internal_signature().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_signature().data(), static_cast<int>(this->_internal_signature().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ApplicationMessage.signature");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ApplicationMessage)
  return target;
}

size_t ApplicationMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ApplicationMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes body = 2;
  if (!this->_internal_body().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_body());
  }

  // string signature = 3;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_signature());
  }

  // .ApplicationMessageHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplicationMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplicationMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplicationMessage::GetClassData() const { return &_class_data_; }


void ApplicationMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplicationMessage*>(&to_msg);
  auto& from = static_cast<const ApplicationMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ApplicationMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_body().empty()) {
    _this->_internal_set_body(from._internal_body());
  }
  if (!from._internal_signature().empty()) {
    _this->_internal_set_signature(from._internal_signature());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::ApplicationMessageHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplicationMessage::CopyFrom(const ApplicationMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ApplicationMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplicationMessage::IsInitialized() const {
  return true;
}

void ApplicationMessage::InternalSwap(ApplicationMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.body_, lhs_arena,
      &other->_impl_.body_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplicationMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[0]);
}

// ===================================================================

class ApplicationMessageHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<ApplicationMessageHeader>()._impl_._has_bits_);
  static const ::Recipients& recipients(const ApplicationMessageHeader* msg);
  static void set_has_qosprofile(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::Recipients&
ApplicationMessageHeader::_Internal::recipients(const ApplicationMessageHeader* msg) {
  return *msg->_impl_.SubjectOrRecipient_.recipients_;
}
void ApplicationMessageHeader::set_allocated_recipients(::Recipients* recipients) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_SubjectOrRecipient();
  if (recipients) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recipients);
    if (message_arena != submessage_arena) {
      recipients = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recipients, submessage_arena);
    }
    set_has_recipients();
    _impl_.SubjectOrRecipient_.recipients_ = recipients;
  }
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessageHeader.recipients)
}
ApplicationMessageHeader::ApplicationMessageHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ApplicationMessageHeader)
}
ApplicationMessageHeader::ApplicationMessageHeader(const ApplicationMessageHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplicationMessageHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sender_){}
    , decltype(_impl_.qosprofile_){}
    , decltype(_impl_.expires_){}
    , decltype(_impl_.bodysizenumbytes_){}
    , decltype(_impl_.SubjectOrRecipient_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sender_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sender().empty()) {
    _this->_impl_.sender_.Set(from._internal_sender(), 
      _this->GetArenaForAllocation());
  }
  _impl_.qosprofile_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.qosprofile_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_qosprofile()) {
    _this->_impl_.qosprofile_.Set(from._internal_qosprofile(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.expires_, &from._impl_.expires_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bodysizenumbytes_) -
    reinterpret_cast<char*>(&_impl_.expires_)) + sizeof(_impl_.bodysizenumbytes_));
  clear_has_SubjectOrRecipient();
  switch (from.SubjectOrRecipient_case()) {
    case kSubject: {
      _this->_internal_set_subject(from._internal_subject());
      break;
    }
    case kRecipients: {
      _this->_internal_mutable_recipients()->::Recipients::MergeFrom(
          from._internal_recipients());
      break;
    }
    case SUBJECTORRECIPIENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:ApplicationMessageHeader)
}

inline void ApplicationMessageHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sender_){}
    , decltype(_impl_.qosprofile_){}
    , decltype(_impl_.expires_){int64_t{0}}
    , decltype(_impl_.bodysizenumbytes_){0u}
    , decltype(_impl_.SubjectOrRecipient_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.sender_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.qosprofile_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.qosprofile_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_SubjectOrRecipient();
}

ApplicationMessageHeader::~ApplicationMessageHeader() {
  // @@protoc_insertion_point(destructor:ApplicationMessageHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplicationMessageHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sender_.Destroy();
  _impl_.qosprofile_.Destroy();
  if (has_SubjectOrRecipient()) {
    clear_SubjectOrRecipient();
  }
}

void ApplicationMessageHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplicationMessageHeader::clear_SubjectOrRecipient() {
// @@protoc_insertion_point(one_of_clear_start:ApplicationMessageHeader)
  switch (SubjectOrRecipient_case()) {
    case kSubject: {
      _impl_.SubjectOrRecipient_.subject_.Destroy();
      break;
    }
    case kRecipients: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.SubjectOrRecipient_.recipients_;
      }
      break;
    }
    case SUBJECTORRECIPIENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SUBJECTORRECIPIENT_NOT_SET;
}


void ApplicationMessageHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:ApplicationMessageHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sender_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.qosprofile_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.expires_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.bodysizenumbytes_) -
      reinterpret_cast<char*>(&_impl_.expires_)) + sizeof(_impl_.bodysizenumbytes_));
  clear_SubjectOrRecipient();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplicationMessageHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subject = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subject();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ApplicationMessageHeader.subject"));
        } else
          goto handle_unusual;
        continue;
      // .Recipients recipients = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_recipients(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 expires = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.expires_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string sender = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_sender();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ApplicationMessageHeader.sender"));
        } else
          goto handle_unusual;
        continue;
      // optional string qosProfile = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_qosprofile();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ApplicationMessageHeader.qosProfile"));
        } else
          goto handle_unusual;
        continue;
      // uint32 bodySizeNumBytes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.bodysizenumbytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplicationMessageHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ApplicationMessageHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subject = 1;
  if (_internal_has_subject()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_subject().data(), static_cast<int>(this->_internal_subject().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ApplicationMessageHeader.subject");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_subject(), target);
  }

  // .Recipients recipients = 2;
  if (_internal_has_recipients()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::recipients(this),
        _Internal::recipients(this).GetCachedSize(), target, stream);
  }

  // int64 expires = 3;
  if (this->_internal_expires() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_expires(), target);
  }

  // string sender = 4;
  if (!this->_internal_sender().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sender().data(), static_cast<int>(this->_internal_sender().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ApplicationMessageHeader.sender");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_sender(), target);
  }

  // optional string qosProfile = 5;
  if (_internal_has_qosprofile()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_qosprofile().data(), static_cast<int>(this->_internal_qosprofile().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ApplicationMessageHeader.qosProfile");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_qosprofile(), target);
  }

  // uint32 bodySizeNumBytes = 6;
  if (this->_internal_bodysizenumbytes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_bodysizenumbytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ApplicationMessageHeader)
  return target;
}

size_t ApplicationMessageHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ApplicationMessageHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string sender = 4;
  if (!this->_internal_sender().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sender());
  }

  // optional string qosProfile = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_qosprofile());
  }

  // int64 expires = 3;
  if (this->_internal_expires() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_expires());
  }

  // uint32 bodySizeNumBytes = 6;
  if (this->_internal_bodysizenumbytes() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bodysizenumbytes());
  }

  switch (SubjectOrRecipient_case()) {
    // string subject = 1;
    case kSubject: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_subject());
      break;
    }
    // .Recipients recipients = 2;
    case kRecipients: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.SubjectOrRecipient_.recipients_);
      break;
    }
    case SUBJECTORRECIPIENT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplicationMessageHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplicationMessageHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplicationMessageHeader::GetClassData() const { return &_class_data_; }


void ApplicationMessageHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplicationMessageHeader*>(&to_msg);
  auto& from = static_cast<const ApplicationMessageHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ApplicationMessageHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_sender().empty()) {
    _this->_internal_set_sender(from._internal_sender());
  }
  if (from._internal_has_qosprofile()) {
    _this->_internal_set_qosprofile(from._internal_qosprofile());
  }
  if (from._internal_expires() != 0) {
    _this->_internal_set_expires(from._internal_expires());
  }
  if (from._internal_bodysizenumbytes() != 0) {
    _this->_internal_set_bodysizenumbytes(from._internal_bodysizenumbytes());
  }
  switch (from.SubjectOrRecipient_case()) {
    case kSubject: {
      _this->_internal_set_subject(from._internal_subject());
      break;
    }
    case kRecipients: {
      _this->_internal_mutable_recipients()->::Recipients::MergeFrom(
          from._internal_recipients());
      break;
    }
    case SUBJECTORRECIPIENT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplicationMessageHeader::CopyFrom(const ApplicationMessageHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ApplicationMessageHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplicationMessageHeader::IsInitialized() const {
  return true;
}

void ApplicationMessageHeader::InternalSwap(ApplicationMessageHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sender_, lhs_arena,
      &other->_impl_.sender_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.qosprofile_, lhs_arena,
      &other->_impl_.qosprofile_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApplicationMessageHeader, _impl_.bodysizenumbytes_)
      + sizeof(ApplicationMessageHeader::_impl_.bodysizenumbytes_)
      - PROTOBUF_FIELD_OFFSET(ApplicationMessageHeader, _impl_.expires_)>(
          reinterpret_cast<char*>(&_impl_.expires_),
          reinterpret_cast<char*>(&other->_impl_.expires_));
  swap(_impl_.SubjectOrRecipient_, other->_impl_.SubjectOrRecipient_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplicationMessageHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[1]);
}

// ===================================================================

class Recipients::_Internal {
 public:
};

Recipients::Recipients(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Recipients)
}
Recipients::Recipients(const Recipients& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Recipients* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.recipients_){from._impl_.recipients_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Recipients)
}

inline void Recipients::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.recipients_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Recipients::~Recipients() {
  // @@protoc_insertion_point(destructor:Recipients)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Recipients::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.recipients_.~RepeatedPtrField();
}

void Recipients::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Recipients::Clear() {
// @@protoc_insertion_point(message_clear_start:Recipients)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.recipients_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Recipients::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string recipients = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_recipients();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "Recipients.recipients"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Recipients::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Recipients)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string recipients = 1;
  for (int i = 0, n = this->_internal_recipients_size(); i < n; i++) {
    const auto& s = this->_internal_recipients(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Recipients.recipients");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Recipients)
  return target;
}

size_t Recipients::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Recipients)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string recipients = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.recipients_.size());
  for (int i = 0, n = _impl_.recipients_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.recipients_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Recipients::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Recipients::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Recipients::GetClassData() const { return &_class_data_; }


void Recipients::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Recipients*>(&to_msg);
  auto& from = static_cast<const Recipients&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Recipients)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.recipients_.MergeFrom(from._impl_.recipients_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Recipients::CopyFrom(const Recipients& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Recipients)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Recipients::IsInitialized() const {
  return true;
}

void Recipients::InternalSwap(Recipients* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.recipients_.InternalSwap(&other->_impl_.recipients_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Recipients::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[2]);
}

// ===================================================================

class MmtpMessage::_Internal {
 public:
  static const ::ProtocolMessage& protocolmessage(const MmtpMessage* msg);
  static const ::ResponseMessage& responsemessage(const MmtpMessage* msg);
};

const ::ProtocolMessage&
MmtpMessage::_Internal::protocolmessage(const MmtpMessage* msg) {
  return *msg->_impl_.body_.protocolmessage_;
}
const ::ResponseMessage&
MmtpMessage::_Internal::responsemessage(const MmtpMessage* msg) {
  return *msg->_impl_.body_.responsemessage_;
}
void MmtpMessage::set_allocated_protocolmessage(::ProtocolMessage* protocolmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (protocolmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(protocolmessage);
    if (message_arena != submessage_arena) {
      protocolmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protocolmessage, submessage_arena);
    }
    set_has_protocolmessage();
    _impl_.body_.protocolmessage_ = protocolmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:MmtpMessage.protocolMessage)
}
void MmtpMessage::set_allocated_responsemessage(::ResponseMessage* responsemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (responsemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(responsemessage);
    if (message_arena != submessage_arena) {
      responsemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, responsemessage, submessage_arena);
    }
    set_has_responsemessage();
    _impl_.body_.responsemessage_ = responsemessage;
  }
  // @@protoc_insertion_point(field_set_allocated:MmtpMessage.responseMessage)
}
MmtpMessage::MmtpMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:MmtpMessage)
}
MmtpMessage::MmtpMessage(const MmtpMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MmtpMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.uuid_){}
    , decltype(_impl_.msgtype_){}
    , decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_uuid().empty()) {
    _this->_impl_.uuid_.Set(from._internal_uuid(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.msgtype_ = from._impl_.msgtype_;
  clear_has_body();
  switch (from.body_case()) {
    case kProtocolMessage: {
      _this->_internal_mutable_protocolmessage()->::ProtocolMessage::MergeFrom(
          from._internal_protocolmessage());
      break;
    }
    case kResponseMessage: {
      _this->_internal_mutable_responsemessage()->::ResponseMessage::MergeFrom(
          from._internal_responsemessage());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:MmtpMessage)
}

inline void MmtpMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.uuid_){}
    , decltype(_impl_.msgtype_){0}
    , decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_body();
}

MmtpMessage::~MmtpMessage() {
  // @@protoc_insertion_point(destructor:MmtpMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmtpMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uuid_.Destroy();
  if (has_body()) {
    clear_body();
  }
}

void MmtpMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmtpMessage::clear_body() {
// @@protoc_insertion_point(one_of_clear_start:MmtpMessage)
  switch (body_case()) {
    case kProtocolMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.protocolmessage_;
      }
      break;
    }
    case kResponseMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.responsemessage_;
      }
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}


void MmtpMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:MmtpMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.uuid_.ClearToEmpty();
  _impl_.msgtype_ = 0;
  clear_body();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MmtpMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .MsgType msgType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_msgtype(static_cast<::MsgType>(val));
        } else
          goto handle_unusual;
        continue;
      // string uuid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "MmtpMessage.uuid"));
        } else
          goto handle_unusual;
        continue;
      // .ProtocolMessage protocolMessage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_protocolmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ResponseMessage responseMessage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_responsemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MmtpMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MmtpMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .MsgType msgType = 1;
  if (this->_internal_msgtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_msgtype(), target);
  }

  // string uuid = 2;
  if (!this->_internal_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_uuid().data(), static_cast<int>(this->_internal_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "MmtpMessage.uuid");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_uuid(), target);
  }

  // .ProtocolMessage protocolMessage = 3;
  if (_internal_has_protocolmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::protocolmessage(this),
        _Internal::protocolmessage(this).GetCachedSize(), target, stream);
  }

  // .ResponseMessage responseMessage = 4;
  if (_internal_has_responsemessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::responsemessage(this),
        _Internal::responsemessage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MmtpMessage)
  return target;
}

size_t MmtpMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MmtpMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string uuid = 2;
  if (!this->_internal_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uuid());
  }

  // .MsgType msgType = 1;
  if (this->_internal_msgtype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_msgtype());
  }

  switch (body_case()) {
    // .ProtocolMessage protocolMessage = 3;
    case kProtocolMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.protocolmessage_);
      break;
    }
    // .ResponseMessage responseMessage = 4;
    case kResponseMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.responsemessage_);
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MmtpMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MmtpMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MmtpMessage::GetClassData() const { return &_class_data_; }


void MmtpMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MmtpMessage*>(&to_msg);
  auto& from = static_cast<const MmtpMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:MmtpMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_uuid().empty()) {
    _this->_internal_set_uuid(from._internal_uuid());
  }
  if (from._internal_msgtype() != 0) {
    _this->_internal_set_msgtype(from._internal_msgtype());
  }
  switch (from.body_case()) {
    case kProtocolMessage: {
      _this->_internal_mutable_protocolmessage()->::ProtocolMessage::MergeFrom(
          from._internal_protocolmessage());
      break;
    }
    case kResponseMessage: {
      _this->_internal_mutable_responsemessage()->::ResponseMessage::MergeFrom(
          from._internal_responsemessage());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MmtpMessage::CopyFrom(const MmtpMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MmtpMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmtpMessage::IsInitialized() const {
  return true;
}

void MmtpMessage::InternalSwap(MmtpMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uuid_, lhs_arena,
      &other->_impl_.uuid_, rhs_arena
  );
  swap(_impl_.msgtype_, other->_impl_.msgtype_);
  swap(_impl_.body_, other->_impl_.body_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata MmtpMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[3]);
}

// ===================================================================

class ProtocolMessage::_Internal {
 public:
  static const ::Subscribe& subscribemessage(const ProtocolMessage* msg);
  static const ::Unsubscribe& unsubscribemessage(const ProtocolMessage* msg);
  static const ::Send& sendmessage(const ProtocolMessage* msg);
  static const ::Receive& receivemessage(const ProtocolMessage* msg);
  static const ::Fetch& fetchmessage(const ProtocolMessage* msg);
  static const ::Disconnect& disconnectmessage(const ProtocolMessage* msg);
  static const ::Connect& connectmessage(const ProtocolMessage* msg);
};

const ::Subscribe&
ProtocolMessage::_Internal::subscribemessage(const ProtocolMessage* msg) {
  return *msg->_impl_.body_.subscribemessage_;
}
const ::Unsubscribe&
ProtocolMessage::_Internal::unsubscribemessage(const ProtocolMessage* msg) {
  return *msg->_impl_.body_.unsubscribemessage_;
}
const ::Send&
ProtocolMessage::_Internal::sendmessage(const ProtocolMessage* msg) {
  return *msg->_impl_.body_.sendmessage_;
}
const ::Receive&
ProtocolMessage::_Internal::receivemessage(const ProtocolMessage* msg) {
  return *msg->_impl_.body_.receivemessage_;
}
const ::Fetch&
ProtocolMessage::_Internal::fetchmessage(const ProtocolMessage* msg) {
  return *msg->_impl_.body_.fetchmessage_;
}
const ::Disconnect&
ProtocolMessage::_Internal::disconnectmessage(const ProtocolMessage* msg) {
  return *msg->_impl_.body_.disconnectmessage_;
}
const ::Connect&
ProtocolMessage::_Internal::connectmessage(const ProtocolMessage* msg) {
  return *msg->_impl_.body_.connectmessage_;
}
void ProtocolMessage::set_allocated_subscribemessage(::Subscribe* subscribemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (subscribemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subscribemessage);
    if (message_arena != submessage_arena) {
      subscribemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscribemessage, submessage_arena);
    }
    set_has_subscribemessage();
    _impl_.body_.subscribemessage_ = subscribemessage;
  }
  // @@protoc_insertion_point(field_set_allocated:ProtocolMessage.subscribeMessage)
}
void ProtocolMessage::set_allocated_unsubscribemessage(::Unsubscribe* unsubscribemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (unsubscribemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(unsubscribemessage);
    if (message_arena != submessage_arena) {
      unsubscribemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unsubscribemessage, submessage_arena);
    }
    set_has_unsubscribemessage();
    _impl_.body_.unsubscribemessage_ = unsubscribemessage;
  }
  // @@protoc_insertion_point(field_set_allocated:ProtocolMessage.unsubscribeMessage)
}
void ProtocolMessage::set_allocated_sendmessage(::Send* sendmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (sendmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sendmessage);
    if (message_arena != submessage_arena) {
      sendmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sendmessage, submessage_arena);
    }
    set_has_sendmessage();
    _impl_.body_.sendmessage_ = sendmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:ProtocolMessage.sendMessage)
}
void ProtocolMessage::set_allocated_receivemessage(::Receive* receivemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (receivemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(receivemessage);
    if (message_arena != submessage_arena) {
      receivemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receivemessage, submessage_arena);
    }
    set_has_receivemessage();
    _impl_.body_.receivemessage_ = receivemessage;
  }
  // @@protoc_insertion_point(field_set_allocated:ProtocolMessage.receiveMessage)
}
void ProtocolMessage::set_allocated_fetchmessage(::Fetch* fetchmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (fetchmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fetchmessage);
    if (message_arena != submessage_arena) {
      fetchmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fetchmessage, submessage_arena);
    }
    set_has_fetchmessage();
    _impl_.body_.fetchmessage_ = fetchmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:ProtocolMessage.fetchMessage)
}
void ProtocolMessage::set_allocated_disconnectmessage(::Disconnect* disconnectmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (disconnectmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(disconnectmessage);
    if (message_arena != submessage_arena) {
      disconnectmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disconnectmessage, submessage_arena);
    }
    set_has_disconnectmessage();
    _impl_.body_.disconnectmessage_ = disconnectmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:ProtocolMessage.disconnectMessage)
}
void ProtocolMessage::set_allocated_connectmessage(::Connect* connectmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (connectmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connectmessage);
    if (message_arena != submessage_arena) {
      connectmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connectmessage, submessage_arena);
    }
    set_has_connectmessage();
    _impl_.body_.connectmessage_ = connectmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:ProtocolMessage.connectMessage)
}
ProtocolMessage::ProtocolMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtocolMessage)
}
ProtocolMessage::ProtocolMessage(const ProtocolMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProtocolMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.protocolmsgtype_){}
    , decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.protocolmsgtype_ = from._impl_.protocolmsgtype_;
  clear_has_body();
  switch (from.body_case()) {
    case kSubscribeMessage: {
      _this->_internal_mutable_subscribemessage()->::Subscribe::MergeFrom(
          from._internal_subscribemessage());
      break;
    }
    case kUnsubscribeMessage: {
      _this->_internal_mutable_unsubscribemessage()->::Unsubscribe::MergeFrom(
          from._internal_unsubscribemessage());
      break;
    }
    case kSendMessage: {
      _this->_internal_mutable_sendmessage()->::Send::MergeFrom(
          from._internal_sendmessage());
      break;
    }
    case kReceiveMessage: {
      _this->_internal_mutable_receivemessage()->::Receive::MergeFrom(
          from._internal_receivemessage());
      break;
    }
    case kFetchMessage: {
      _this->_internal_mutable_fetchmessage()->::Fetch::MergeFrom(
          from._internal_fetchmessage());
      break;
    }
    case kDisconnectMessage: {
      _this->_internal_mutable_disconnectmessage()->::Disconnect::MergeFrom(
          from._internal_disconnectmessage());
      break;
    }
    case kConnectMessage: {
      _this->_internal_mutable_connectmessage()->::Connect::MergeFrom(
          from._internal_connectmessage());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:ProtocolMessage)
}

inline void ProtocolMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.protocolmsgtype_){0}
    , decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_body();
}

ProtocolMessage::~ProtocolMessage() {
  // @@protoc_insertion_point(destructor:ProtocolMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProtocolMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_body()) {
    clear_body();
  }
}

void ProtocolMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProtocolMessage::clear_body() {
// @@protoc_insertion_point(one_of_clear_start:ProtocolMessage)
  switch (body_case()) {
    case kSubscribeMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.subscribemessage_;
      }
      break;
    }
    case kUnsubscribeMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.unsubscribemessage_;
      }
      break;
    }
    case kSendMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.sendmessage_;
      }
      break;
    }
    case kReceiveMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.receivemessage_;
      }
      break;
    }
    case kFetchMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.fetchmessage_;
      }
      break;
    }
    case kDisconnectMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.disconnectmessage_;
      }
      break;
    }
    case kConnectMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.connectmessage_;
      }
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}


void ProtocolMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtocolMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.protocolmsgtype_ = 0;
  clear_body();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProtocolMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .ProtocolMessageType protocolMsgType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_protocolmsgtype(static_cast<::ProtocolMessageType>(val));
        } else
          goto handle_unusual;
        continue;
      // .Subscribe subscribeMessage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_subscribemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Unsubscribe unsubscribeMessage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_unsubscribemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Send sendMessage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_sendmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Receive receiveMessage = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_receivemessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Fetch fetchMessage = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_fetchmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Disconnect disconnectMessage = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_disconnectmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Connect connectMessage = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_connectmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProtocolMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtocolMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .ProtocolMessageType protocolMsgType = 1;
  if (this->_internal_protocolmsgtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_protocolmsgtype(), target);
  }

  // .Subscribe subscribeMessage = 2;
  if (_internal_has_subscribemessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::subscribemessage(this),
        _Internal::subscribemessage(this).GetCachedSize(), target, stream);
  }

  // .Unsubscribe unsubscribeMessage = 3;
  if (_internal_has_unsubscribemessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::unsubscribemessage(this),
        _Internal::unsubscribemessage(this).GetCachedSize(), target, stream);
  }

  // .Send sendMessage = 4;
  if (_internal_has_sendmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::sendmessage(this),
        _Internal::sendmessage(this).GetCachedSize(), target, stream);
  }

  // .Receive receiveMessage = 5;
  if (_internal_has_receivemessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::receivemessage(this),
        _Internal::receivemessage(this).GetCachedSize(), target, stream);
  }

  // .Fetch fetchMessage = 6;
  if (_internal_has_fetchmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::fetchmessage(this),
        _Internal::fetchmessage(this).GetCachedSize(), target, stream);
  }

  // .Disconnect disconnectMessage = 7;
  if (_internal_has_disconnectmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::disconnectmessage(this),
        _Internal::disconnectmessage(this).GetCachedSize(), target, stream);
  }

  // .Connect connectMessage = 8;
  if (_internal_has_connectmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::connectmessage(this),
        _Internal::connectmessage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtocolMessage)
  return target;
}

size_t ProtocolMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtocolMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .ProtocolMessageType protocolMsgType = 1;
  if (this->_internal_protocolmsgtype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_protocolmsgtype());
  }

  switch (body_case()) {
    // .Subscribe subscribeMessage = 2;
    case kSubscribeMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.subscribemessage_);
      break;
    }
    // .Unsubscribe unsubscribeMessage = 3;
    case kUnsubscribeMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.unsubscribemessage_);
      break;
    }
    // .Send sendMessage = 4;
    case kSendMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.sendmessage_);
      break;
    }
    // .Receive receiveMessage = 5;
    case kReceiveMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.receivemessage_);
      break;
    }
    // .Fetch fetchMessage = 6;
    case kFetchMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.fetchmessage_);
      break;
    }
    // .Disconnect disconnectMessage = 7;
    case kDisconnectMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.disconnectmessage_);
      break;
    }
    // .Connect connectMessage = 8;
    case kConnectMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.connectmessage_);
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProtocolMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProtocolMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProtocolMessage::GetClassData() const { return &_class_data_; }


void ProtocolMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProtocolMessage*>(&to_msg);
  auto& from = static_cast<const ProtocolMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtocolMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_protocolmsgtype() != 0) {
    _this->_internal_set_protocolmsgtype(from._internal_protocolmsgtype());
  }
  switch (from.body_case()) {
    case kSubscribeMessage: {
      _this->_internal_mutable_subscribemessage()->::Subscribe::MergeFrom(
          from._internal_subscribemessage());
      break;
    }
    case kUnsubscribeMessage: {
      _this->_internal_mutable_unsubscribemessage()->::Unsubscribe::MergeFrom(
          from._internal_unsubscribemessage());
      break;
    }
    case kSendMessage: {
      _this->_internal_mutable_sendmessage()->::Send::MergeFrom(
          from._internal_sendmessage());
      break;
    }
    case kReceiveMessage: {
      _this->_internal_mutable_receivemessage()->::Receive::MergeFrom(
          from._internal_receivemessage());
      break;
    }
    case kFetchMessage: {
      _this->_internal_mutable_fetchmessage()->::Fetch::MergeFrom(
          from._internal_fetchmessage());
      break;
    }
    case kDisconnectMessage: {
      _this->_internal_mutable_disconnectmessage()->::Disconnect::MergeFrom(
          from._internal_disconnectmessage());
      break;
    }
    case kConnectMessage: {
      _this->_internal_mutable_connectmessage()->::Connect::MergeFrom(
          from._internal_connectmessage());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProtocolMessage::CopyFrom(const ProtocolMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtocolMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtocolMessage::IsInitialized() const {
  return true;
}

void ProtocolMessage::InternalSwap(ProtocolMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.protocolmsgtype_, other->_impl_.protocolmsgtype_);
  swap(_impl_.body_, other->_impl_.body_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProtocolMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[4]);
}

// ===================================================================

class Subscribe::_Internal {
 public:
};

Subscribe::Subscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Subscribe)
}
Subscribe::Subscribe(const Subscribe& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Subscribe* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subjectOrDirectMessages_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_subjectOrDirectMessages();
  switch (from.subjectOrDirectMessages_case()) {
    case kSubject: {
      _this->_internal_set_subject(from._internal_subject());
      break;
    }
    case kDirectMessages: {
      _this->_internal_set_directmessages(from._internal_directmessages());
      break;
    }
    case SUBJECTORDIRECTMESSAGES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Subscribe)
}

inline void Subscribe::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.subjectOrDirectMessages_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_subjectOrDirectMessages();
}

Subscribe::~Subscribe() {
  // @@protoc_insertion_point(destructor:Subscribe)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Subscribe::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_subjectOrDirectMessages()) {
    clear_subjectOrDirectMessages();
  }
}

void Subscribe::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Subscribe::clear_subjectOrDirectMessages() {
// @@protoc_insertion_point(one_of_clear_start:Subscribe)
  switch (subjectOrDirectMessages_case()) {
    case kSubject: {
      _impl_.subjectOrDirectMessages_.subject_.Destroy();
      break;
    }
    case kDirectMessages: {
      // No need to clear
      break;
    }
    case SUBJECTORDIRECTMESSAGES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SUBJECTORDIRECTMESSAGES_NOT_SET;
}


void Subscribe::Clear() {
// @@protoc_insertion_point(message_clear_start:Subscribe)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_subjectOrDirectMessages();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Subscribe::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subject = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subject();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Subscribe.subject"));
        } else
          goto handle_unusual;
        continue;
      // bool directMessages = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_directmessages(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Subscribe::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Subscribe)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subject = 1;
  if (_internal_has_subject()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_subject().data(), static_cast<int>(this->_internal_subject().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Subscribe.subject");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_subject(), target);
  }

  // bool directMessages = 2;
  if (_internal_has_directmessages()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_directmessages(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Subscribe)
  return target;
}

size_t Subscribe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Subscribe)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (subjectOrDirectMessages_case()) {
    // string subject = 1;
    case kSubject: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_subject());
      break;
    }
    // bool directMessages = 2;
    case kDirectMessages: {
      total_size += 1 + 1;
      break;
    }
    case SUBJECTORDIRECTMESSAGES_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Subscribe::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Subscribe::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Subscribe::GetClassData() const { return &_class_data_; }


void Subscribe::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Subscribe*>(&to_msg);
  auto& from = static_cast<const Subscribe&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Subscribe)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.subjectOrDirectMessages_case()) {
    case kSubject: {
      _this->_internal_set_subject(from._internal_subject());
      break;
    }
    case kDirectMessages: {
      _this->_internal_set_directmessages(from._internal_directmessages());
      break;
    }
    case SUBJECTORDIRECTMESSAGES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Subscribe::CopyFrom(const Subscribe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Subscribe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Subscribe::IsInitialized() const {
  return true;
}

void Subscribe::InternalSwap(Subscribe* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.subjectOrDirectMessages_, other->_impl_.subjectOrDirectMessages_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Subscribe::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[5]);
}

// ===================================================================

class Unsubscribe::_Internal {
 public:
};

Unsubscribe::Unsubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Unsubscribe)
}
Unsubscribe::Unsubscribe(const Unsubscribe& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Unsubscribe* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subjectOrDirectMessages_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_subjectOrDirectMessages();
  switch (from.subjectOrDirectMessages_case()) {
    case kSubject: {
      _this->_internal_set_subject(from._internal_subject());
      break;
    }
    case kDirectMessages: {
      _this->_internal_set_directmessages(from._internal_directmessages());
      break;
    }
    case SUBJECTORDIRECTMESSAGES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Unsubscribe)
}

inline void Unsubscribe::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.subjectOrDirectMessages_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_subjectOrDirectMessages();
}

Unsubscribe::~Unsubscribe() {
  // @@protoc_insertion_point(destructor:Unsubscribe)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Unsubscribe::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_subjectOrDirectMessages()) {
    clear_subjectOrDirectMessages();
  }
}

void Unsubscribe::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Unsubscribe::clear_subjectOrDirectMessages() {
// @@protoc_insertion_point(one_of_clear_start:Unsubscribe)
  switch (subjectOrDirectMessages_case()) {
    case kSubject: {
      _impl_.subjectOrDirectMessages_.subject_.Destroy();
      break;
    }
    case kDirectMessages: {
      // No need to clear
      break;
    }
    case SUBJECTORDIRECTMESSAGES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SUBJECTORDIRECTMESSAGES_NOT_SET;
}


void Unsubscribe::Clear() {
// @@protoc_insertion_point(message_clear_start:Unsubscribe)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_subjectOrDirectMessages();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Unsubscribe::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subject = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subject();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Unsubscribe.subject"));
        } else
          goto handle_unusual;
        continue;
      // bool directMessages = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_directmessages(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Unsubscribe::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Unsubscribe)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subject = 1;
  if (_internal_has_subject()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_subject().data(), static_cast<int>(this->_internal_subject().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Unsubscribe.subject");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_subject(), target);
  }

  // bool directMessages = 2;
  if (_internal_has_directmessages()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_directmessages(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Unsubscribe)
  return target;
}

size_t Unsubscribe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Unsubscribe)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (subjectOrDirectMessages_case()) {
    // string subject = 1;
    case kSubject: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_subject());
      break;
    }
    // bool directMessages = 2;
    case kDirectMessages: {
      total_size += 1 + 1;
      break;
    }
    case SUBJECTORDIRECTMESSAGES_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Unsubscribe::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Unsubscribe::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Unsubscribe::GetClassData() const { return &_class_data_; }


void Unsubscribe::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Unsubscribe*>(&to_msg);
  auto& from = static_cast<const Unsubscribe&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Unsubscribe)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.subjectOrDirectMessages_case()) {
    case kSubject: {
      _this->_internal_set_subject(from._internal_subject());
      break;
    }
    case kDirectMessages: {
      _this->_internal_set_directmessages(from._internal_directmessages());
      break;
    }
    case SUBJECTORDIRECTMESSAGES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Unsubscribe::CopyFrom(const Unsubscribe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Unsubscribe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Unsubscribe::IsInitialized() const {
  return true;
}

void Unsubscribe::InternalSwap(Unsubscribe* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.subjectOrDirectMessages_, other->_impl_.subjectOrDirectMessages_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Unsubscribe::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[6]);
}

// ===================================================================

class Send::_Internal {
 public:
  static const ::ApplicationMessage& applicationmessage(const Send* msg);
};

const ::ApplicationMessage&
Send::_Internal::applicationmessage(const Send* msg) {
  return *msg->_impl_.applicationmessage_;
}
Send::Send(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Send)
}
Send::Send(const Send& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Send* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.applicationmessage_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_applicationmessage()) {
    _this->_impl_.applicationmessage_ = new ::ApplicationMessage(*from._impl_.applicationmessage_);
  }
  // @@protoc_insertion_point(copy_constructor:Send)
}

inline void Send::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.applicationmessage_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Send::~Send() {
  // @@protoc_insertion_point(destructor:Send)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Send::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.applicationmessage_;
}

void Send::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Send::Clear() {
// @@protoc_insertion_point(message_clear_start:Send)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.applicationmessage_ != nullptr) {
    delete _impl_.applicationmessage_;
  }
  _impl_.applicationmessage_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Send::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .ApplicationMessage applicationMessage = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_applicationmessage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Send::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Send)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .ApplicationMessage applicationMessage = 1;
  if (this->_internal_has_applicationmessage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::applicationmessage(this),
        _Internal::applicationmessage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Send)
  return target;
}

size_t Send::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Send)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .ApplicationMessage applicationMessage = 1;
  if (this->_internal_has_applicationmessage()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.applicationmessage_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Send::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Send::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Send::GetClassData() const { return &_class_data_; }


void Send::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Send*>(&to_msg);
  auto& from = static_cast<const Send&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Send)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_applicationmessage()) {
    _this->_internal_mutable_applicationmessage()->::ApplicationMessage::MergeFrom(
        from._internal_applicationmessage());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Send::CopyFrom(const Send& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Send)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Send::IsInitialized() const {
  return true;
}

void Send::InternalSwap(Send* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.applicationmessage_, other->_impl_.applicationmessage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Send::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[7]);
}

// ===================================================================

class Receive::_Internal {
 public:
  using HasBits = decltype(std::declval<Receive>()._impl_._has_bits_);
  static const ::Filter& filter(const Receive* msg);
  static void set_has_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::Filter&
Receive::_Internal::filter(const Receive* msg) {
  return *msg->_impl_.filter_;
}
Receive::Receive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Receive)
}
Receive::Receive(const Receive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Receive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filter_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_filter()) {
    _this->_impl_.filter_ = new ::Filter(*from._impl_.filter_);
  }
  // @@protoc_insertion_point(copy_constructor:Receive)
}

inline void Receive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filter_){nullptr}
  };
}

Receive::~Receive() {
  // @@protoc_insertion_point(destructor:Receive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Receive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.filter_;
}

void Receive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Receive::Clear() {
// @@protoc_insertion_point(message_clear_start:Receive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.filter_ != nullptr);
    _impl_.filter_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Receive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .Filter filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Receive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Receive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .Filter filter = 1;
  if (_internal_has_filter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::filter(this),
        _Internal::filter(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Receive)
  return target;
}

size_t Receive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Receive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .Filter filter = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.filter_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Receive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Receive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Receive::GetClassData() const { return &_class_data_; }


void Receive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Receive*>(&to_msg);
  auto& from = static_cast<const Receive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Receive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_filter()) {
    _this->_internal_mutable_filter()->::Filter::MergeFrom(
        from._internal_filter());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Receive::CopyFrom(const Receive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Receive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Receive::IsInitialized() const {
  return true;
}

void Receive::InternalSwap(Receive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.filter_, other->_impl_.filter_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Receive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[8]);
}

// ===================================================================

class Filter::_Internal {
 public:
};

Filter::Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Filter)
}
Filter::Filter(const Filter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Filter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messageuuids_){from._impl_.messageuuids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Filter)
}

inline void Filter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.messageuuids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Filter::~Filter() {
  // @@protoc_insertion_point(destructor:Filter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Filter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.messageuuids_.~RepeatedPtrField();
}

void Filter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Filter::Clear() {
// @@protoc_insertion_point(message_clear_start:Filter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.messageuuids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Filter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string messageUuids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_messageuuids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "Filter.messageUuids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Filter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Filter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string messageUuids = 1;
  for (int i = 0, n = this->_internal_messageuuids_size(); i < n; i++) {
    const auto& s = this->_internal_messageuuids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Filter.messageUuids");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Filter)
  return target;
}

size_t Filter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Filter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string messageUuids = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.messageuuids_.size());
  for (int i = 0, n = _impl_.messageuuids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.messageuuids_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Filter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Filter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Filter::GetClassData() const { return &_class_data_; }


void Filter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Filter*>(&to_msg);
  auto& from = static_cast<const Filter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Filter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.messageuuids_.MergeFrom(from._impl_.messageuuids_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Filter::CopyFrom(const Filter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Filter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Filter::IsInitialized() const {
  return true;
}

void Filter::InternalSwap(Filter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.messageuuids_.InternalSwap(&other->_impl_.messageuuids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Filter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[9]);
}

// ===================================================================

class Fetch::_Internal {
 public:
};

Fetch::Fetch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Fetch)
}
Fetch::Fetch(const Fetch& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Fetch* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Fetch)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Fetch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Fetch::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Fetch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[10]);
}

// ===================================================================

class Disconnect::_Internal {
 public:
};

Disconnect::Disconnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Disconnect)
}
Disconnect::Disconnect(const Disconnect& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Disconnect* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Disconnect)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Disconnect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Disconnect::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Disconnect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[11]);
}

// ===================================================================

class Connect::_Internal {
 public:
  using HasBits = decltype(std::declval<Connect>()._impl_._has_bits_);
  static void set_has_ownmrn(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reconnecttoken(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Connect::Connect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Connect)
}
Connect::Connect(const Connect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Connect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ownmrn_){}
    , decltype(_impl_.reconnecttoken_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ownmrn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownmrn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownmrn()) {
    _this->_impl_.ownmrn_.Set(from._internal_ownmrn(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reconnecttoken_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reconnecttoken_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reconnecttoken()) {
    _this->_impl_.reconnecttoken_.Set(from._internal_reconnecttoken(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Connect)
}

inline void Connect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ownmrn_){}
    , decltype(_impl_.reconnecttoken_){}
  };
  _impl_.ownmrn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownmrn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reconnecttoken_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reconnecttoken_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Connect::~Connect() {
  // @@protoc_insertion_point(destructor:Connect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Connect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ownmrn_.Destroy();
  _impl_.reconnecttoken_.Destroy();
}

void Connect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Connect::Clear() {
// @@protoc_insertion_point(message_clear_start:Connect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ownmrn_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.reconnecttoken_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Connect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ownMrn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ownmrn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Connect.ownMrn"));
        } else
          goto handle_unusual;
        continue;
      // optional string reconnectToken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_reconnecttoken();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Connect.reconnectToken"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Connect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Connect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string ownMrn = 1;
  if (_internal_has_ownmrn()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ownmrn().data(), static_cast<int>(this->_internal_ownmrn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Connect.ownMrn");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ownmrn(), target);
  }

  // optional string reconnectToken = 2;
  if (_internal_has_reconnecttoken()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_reconnecttoken().data(), static_cast<int>(this->_internal_reconnecttoken().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Connect.reconnectToken");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_reconnecttoken(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Connect)
  return target;
}

size_t Connect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Connect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string ownMrn = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ownmrn());
    }

    // optional string reconnectToken = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reconnecttoken());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Connect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Connect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Connect::GetClassData() const { return &_class_data_; }


void Connect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Connect*>(&to_msg);
  auto& from = static_cast<const Connect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Connect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ownmrn(from._internal_ownmrn());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_reconnecttoken(from._internal_reconnecttoken());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Connect::CopyFrom(const Connect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Connect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Connect::IsInitialized() const {
  return true;
}

void Connect::InternalSwap(Connect* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ownmrn_, lhs_arena,
      &other->_impl_.ownmrn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reconnecttoken_, lhs_arena,
      &other->_impl_.reconnecttoken_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Connect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[12]);
}

// ===================================================================

class ResponseMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseMessage>()._impl_._has_bits_);
  static void set_has_reasontext(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reconnecttoken(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ResponseMessage::ResponseMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ResponseMessage)
}
ResponseMessage::ResponseMessage(const ResponseMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.messagemetadata_){from._impl_.messagemetadata_}
    , decltype(_impl_.applicationmessages_){from._impl_.applicationmessages_}
    , decltype(_impl_.responsetouuid_){}
    , decltype(_impl_.reasontext_){}
    , decltype(_impl_.reconnecttoken_){}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.responsetouuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.responsetouuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_responsetouuid().empty()) {
    _this->_impl_.responsetouuid_.Set(from._internal_responsetouuid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reasontext_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reasontext_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reasontext()) {
    _this->_impl_.reasontext_.Set(from._internal_reasontext(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reconnecttoken_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reconnecttoken_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reconnecttoken()) {
    _this->_impl_.reconnecttoken_.Set(from._internal_reconnecttoken(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:ResponseMessage)
}

inline void ResponseMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.messagemetadata_){arena}
    , decltype(_impl_.applicationmessages_){arena}
    , decltype(_impl_.responsetouuid_){}
    , decltype(_impl_.reasontext_){}
    , decltype(_impl_.reconnecttoken_){}
    , decltype(_impl_.response_){0}
  };
  _impl_.responsetouuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.responsetouuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reasontext_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reasontext_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reconnecttoken_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reconnecttoken_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResponseMessage::~ResponseMessage() {
  // @@protoc_insertion_point(destructor:ResponseMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.messagemetadata_.~RepeatedPtrField();
  _impl_.applicationmessages_.~RepeatedPtrField();
  _impl_.responsetouuid_.Destroy();
  _impl_.reasontext_.Destroy();
  _impl_.reconnecttoken_.Destroy();
}

void ResponseMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ResponseMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.messagemetadata_.Clear();
  _impl_.applicationmessages_.Clear();
  _impl_.responsetouuid_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.reasontext_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.reconnecttoken_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string responseToUuid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_responsetouuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ResponseMessage.responseToUuid"));
        } else
          goto handle_unusual;
        continue;
      // .ResponseEnum response = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_response(static_cast<::ResponseEnum>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string reasonText = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_reasontext();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ResponseMessage.reasonText"));
        } else
          goto handle_unusual;
        continue;
      // repeated .MessageMetadata messageMetadata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_messagemetadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ApplicationMessage applicationMessages = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_applicationmessages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string reconnectToken = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_reconnecttoken();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ResponseMessage.reconnectToken"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ResponseMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string responseToUuid = 1;
  if (!this->_internal_responsetouuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_responsetouuid().data(), static_cast<int>(this->_internal_responsetouuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ResponseMessage.responseToUuid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_responsetouuid(), target);
  }

  // .ResponseEnum response = 2;
  if (this->_internal_response() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_response(), target);
  }

  // optional string reasonText = 3;
  if (_internal_has_reasontext()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_reasontext().data(), static_cast<int>(this->_internal_reasontext().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ResponseMessage.reasonText");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_reasontext(), target);
  }

  // repeated .MessageMetadata messageMetadata = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_messagemetadata_size()); i < n; i++) {
    const auto& repfield = this->_internal_messagemetadata(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ApplicationMessage applicationMessages = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_applicationmessages_size()); i < n; i++) {
    const auto& repfield = this->_internal_applicationmessages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string reconnectToken = 6;
  if (_internal_has_reconnecttoken()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_reconnecttoken().data(), static_cast<int>(this->_internal_reconnecttoken().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ResponseMessage.reconnectToken");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_reconnecttoken(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ResponseMessage)
  return target;
}

size_t ResponseMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ResponseMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MessageMetadata messageMetadata = 4;
  total_size += 1UL * this->_internal_messagemetadata_size();
  for (const auto& msg : this->_impl_.messagemetadata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ApplicationMessage applicationMessages = 5;
  total_size += 1UL * this->_internal_applicationmessages_size();
  for (const auto& msg : this->_impl_.applicationmessages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string responseToUuid = 1;
  if (!this->_internal_responsetouuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_responsetouuid());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string reasonText = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reasontext());
    }

    // optional string reconnectToken = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reconnecttoken());
    }

  }
  // .ResponseEnum response = 2;
  if (this->_internal_response() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseMessage::GetClassData() const { return &_class_data_; }


void ResponseMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseMessage*>(&to_msg);
  auto& from = static_cast<const ResponseMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ResponseMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.messagemetadata_.MergeFrom(from._impl_.messagemetadata_);
  _this->_impl_.applicationmessages_.MergeFrom(from._impl_.applicationmessages_);
  if (!from._internal_responsetouuid().empty()) {
    _this->_internal_set_responsetouuid(from._internal_responsetouuid());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_reasontext(from._internal_reasontext());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_reconnecttoken(from._internal_reconnecttoken());
    }
  }
  if (from._internal_response() != 0) {
    _this->_internal_set_response(from._internal_response());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseMessage::CopyFrom(const ResponseMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ResponseMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseMessage::IsInitialized() const {
  return true;
}

void ResponseMessage::InternalSwap(ResponseMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.messagemetadata_.InternalSwap(&other->_impl_.messagemetadata_);
  _impl_.applicationmessages_.InternalSwap(&other->_impl_.applicationmessages_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.responsetouuid_, lhs_arena,
      &other->_impl_.responsetouuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reasontext_, lhs_arena,
      &other->_impl_.reasontext_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reconnecttoken_, lhs_arena,
      &other->_impl_.reconnecttoken_, rhs_arena
  );
  swap(_impl_.response_, other->_impl_.response_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[13]);
}

// ===================================================================

class MessageMetadata::_Internal {
 public:
  static const ::ApplicationMessageHeader& header(const MessageMetadata* msg);
};

const ::ApplicationMessageHeader&
MessageMetadata::_Internal::header(const MessageMetadata* msg) {
  return *msg->_impl_.header_;
}
MessageMetadata::MessageMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:MessageMetadata)
}
MessageMetadata::MessageMetadata(const MessageMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MessageMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.uuid_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_uuid().empty()) {
    _this->_impl_.uuid_.Set(from._internal_uuid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::ApplicationMessageHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:MessageMetadata)
}

inline void MessageMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.uuid_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MessageMetadata::~MessageMetadata() {
  // @@protoc_insertion_point(destructor:MessageMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MessageMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uuid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void MessageMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MessageMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:MessageMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.uuid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MessageMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string uuid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "MessageMetadata.uuid"));
        } else
          goto handle_unusual;
        continue;
      // .ApplicationMessageHeader header = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MessageMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MessageMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string uuid = 1;
  if (!this->_internal_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_uuid().data(), static_cast<int>(this->_internal_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "MessageMetadata.uuid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_uuid(), target);
  }

  // .ApplicationMessageHeader header = 2;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MessageMetadata)
  return target;
}

size_t MessageMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MessageMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string uuid = 1;
  if (!this->_internal_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uuid());
  }

  // .ApplicationMessageHeader header = 2;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MessageMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MessageMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MessageMetadata::GetClassData() const { return &_class_data_; }


void MessageMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MessageMetadata*>(&to_msg);
  auto& from = static_cast<const MessageMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:MessageMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_uuid().empty()) {
    _this->_internal_set_uuid(from._internal_uuid());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::ApplicationMessageHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MessageMetadata::CopyFrom(const MessageMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MessageMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageMetadata::IsInitialized() const {
  return true;
}

void MessageMetadata::InternalSwap(MessageMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uuid_, lhs_arena,
      &other->_impl_.uuid_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MessageMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mmtp_2eproto_getter, &descriptor_table_mmtp_2eproto_once,
      file_level_metadata_mmtp_2eproto[14]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::ApplicationMessage*
Arena::CreateMaybeMessage< ::ApplicationMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ApplicationMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ApplicationMessageHeader*
Arena::CreateMaybeMessage< ::ApplicationMessageHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ApplicationMessageHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::Recipients*
Arena::CreateMaybeMessage< ::Recipients >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Recipients >(arena);
}
template<> PROTOBUF_NOINLINE ::MmtpMessage*
Arena::CreateMaybeMessage< ::MmtpMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MmtpMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtocolMessage*
Arena::CreateMaybeMessage< ::ProtocolMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtocolMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::Subscribe*
Arena::CreateMaybeMessage< ::Subscribe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Subscribe >(arena);
}
template<> PROTOBUF_NOINLINE ::Unsubscribe*
Arena::CreateMaybeMessage< ::Unsubscribe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Unsubscribe >(arena);
}
template<> PROTOBUF_NOINLINE ::Send*
Arena::CreateMaybeMessage< ::Send >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Send >(arena);
}
template<> PROTOBUF_NOINLINE ::Receive*
Arena::CreateMaybeMessage< ::Receive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Receive >(arena);
}
template<> PROTOBUF_NOINLINE ::Filter*
Arena::CreateMaybeMessage< ::Filter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Filter >(arena);
}
template<> PROTOBUF_NOINLINE ::Fetch*
Arena::CreateMaybeMessage< ::Fetch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Fetch >(arena);
}
template<> PROTOBUF_NOINLINE ::Disconnect*
Arena::CreateMaybeMessage< ::Disconnect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Disconnect >(arena);
}
template<> PROTOBUF_NOINLINE ::Connect*
Arena::CreateMaybeMessage< ::Connect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Connect >(arena);
}
template<> PROTOBUF_NOINLINE ::ResponseMessage*
Arena::CreateMaybeMessage< ::ResponseMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ResponseMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::MessageMetadata*
Arena::CreateMaybeMessage< ::MessageMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MessageMetadata >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

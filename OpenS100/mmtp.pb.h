#include "pch.h"

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmtp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mmtp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mmtp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mmtp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mmtp_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mmtp_2eproto;
class ApplicationMessage;
struct ApplicationMessageDefaultTypeInternal;
extern ApplicationMessageDefaultTypeInternal _ApplicationMessage_default_instance_;
class ApplicationMessageHeader;
struct ApplicationMessageHeaderDefaultTypeInternal;
extern ApplicationMessageHeaderDefaultTypeInternal _ApplicationMessageHeader_default_instance_;
class Connect;
struct ConnectDefaultTypeInternal;
extern ConnectDefaultTypeInternal _Connect_default_instance_;
class Disconnect;
struct DisconnectDefaultTypeInternal;
extern DisconnectDefaultTypeInternal _Disconnect_default_instance_;
class Fetch;
struct FetchDefaultTypeInternal;
extern FetchDefaultTypeInternal _Fetch_default_instance_;
class Filter;
struct FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class MessageMetadata;
struct MessageMetadataDefaultTypeInternal;
extern MessageMetadataDefaultTypeInternal _MessageMetadata_default_instance_;
class MmtpMessage;
struct MmtpMessageDefaultTypeInternal;
extern MmtpMessageDefaultTypeInternal _MmtpMessage_default_instance_;
class ProtocolMessage;
struct ProtocolMessageDefaultTypeInternal;
extern ProtocolMessageDefaultTypeInternal _ProtocolMessage_default_instance_;
class Receive;
struct ReceiveDefaultTypeInternal;
extern ReceiveDefaultTypeInternal _Receive_default_instance_;
class Recipients;
struct RecipientsDefaultTypeInternal;
extern RecipientsDefaultTypeInternal _Recipients_default_instance_;
class ResponseMessage;
struct ResponseMessageDefaultTypeInternal;
extern ResponseMessageDefaultTypeInternal _ResponseMessage_default_instance_;
class Send;
struct SendDefaultTypeInternal;
extern SendDefaultTypeInternal _Send_default_instance_;
class Subscribe;
struct SubscribeDefaultTypeInternal;
extern SubscribeDefaultTypeInternal _Subscribe_default_instance_;
class Unsubscribe;
struct UnsubscribeDefaultTypeInternal;
extern UnsubscribeDefaultTypeInternal _Unsubscribe_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ApplicationMessage* Arena::CreateMaybeMessage<::ApplicationMessage>(Arena*);
template<> ::ApplicationMessageHeader* Arena::CreateMaybeMessage<::ApplicationMessageHeader>(Arena*);
template<> ::Connect* Arena::CreateMaybeMessage<::Connect>(Arena*);
template<> ::Disconnect* Arena::CreateMaybeMessage<::Disconnect>(Arena*);
template<> ::Fetch* Arena::CreateMaybeMessage<::Fetch>(Arena*);
template<> ::Filter* Arena::CreateMaybeMessage<::Filter>(Arena*);
template<> ::MessageMetadata* Arena::CreateMaybeMessage<::MessageMetadata>(Arena*);
template<> ::MmtpMessage* Arena::CreateMaybeMessage<::MmtpMessage>(Arena*);
template<> ::ProtocolMessage* Arena::CreateMaybeMessage<::ProtocolMessage>(Arena*);
template<> ::Receive* Arena::CreateMaybeMessage<::Receive>(Arena*);
template<> ::Recipients* Arena::CreateMaybeMessage<::Recipients>(Arena*);
template<> ::ResponseMessage* Arena::CreateMaybeMessage<::ResponseMessage>(Arena*);
template<> ::Send* Arena::CreateMaybeMessage<::Send>(Arena*);
template<> ::Subscribe* Arena::CreateMaybeMessage<::Subscribe>(Arena*);
template<> ::Unsubscribe* Arena::CreateMaybeMessage<::Unsubscribe>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum MsgType : int {
  UNSPECIFIED_MESSAGE = 0,
  PROTOCOL_MESSAGE = 1,
  RESPONSE_MESSAGE = 2,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = UNSPECIFIED_MESSAGE;
constexpr MsgType MsgType_MAX = RESPONSE_MESSAGE;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor();
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgType_descriptor(), enum_t_value);
}
inline bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum ProtocolMessageType : int {
  UNSPECIFIED = 0,
  SUBSCRIBE_MESSAGE = 1,
  UNSUBSCRIBE_MESSAGE = 2,
  SEND_MESSAGE = 3,
  RECEIVE_MESSAGE = 4,
  FETCH_MESSAGE = 5,
  DISCONNECT_MESSAGE = 6,
  CONNECT_MESSAGE = 7,
  ProtocolMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProtocolMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProtocolMessageType_IsValid(int value);
constexpr ProtocolMessageType ProtocolMessageType_MIN = UNSPECIFIED;
constexpr ProtocolMessageType ProtocolMessageType_MAX = CONNECT_MESSAGE;
constexpr int ProtocolMessageType_ARRAYSIZE = ProtocolMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProtocolMessageType_descriptor();
template<typename T>
inline const std::string& ProtocolMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProtocolMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProtocolMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProtocolMessageType_descriptor(), enum_t_value);
}
inline bool ProtocolMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProtocolMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProtocolMessageType>(
    ProtocolMessageType_descriptor(), name, value);
}
enum ResponseEnum : int {
  UNSPECIFIED_RESPONSE = 0,
  GOOD = 1,
  ERROR = 2,
  ResponseEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ResponseEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ResponseEnum_IsValid(int value);
constexpr ResponseEnum ResponseEnum_MIN = UNSPECIFIED_RESPONSE;
constexpr ResponseEnum ResponseEnum_MAX = ERROR;
constexpr int ResponseEnum_ARRAYSIZE = ResponseEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseEnum_descriptor();
template<typename T>
inline const std::string& ResponseEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseEnum_descriptor(), enum_t_value);
}
inline bool ResponseEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseEnum>(
    ResponseEnum_descriptor(), name, value);
}
// ===================================================================

class ApplicationMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ApplicationMessage) */ {
 public:
  inline ApplicationMessage() : ApplicationMessage(nullptr) {}
  ~ApplicationMessage() override;
  explicit PROTOBUF_CONSTEXPR ApplicationMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplicationMessage(const ApplicationMessage& from);
  ApplicationMessage(ApplicationMessage&& from) noexcept
    : ApplicationMessage() {
    *this = ::std::move(from);
  }

  inline ApplicationMessage& operator=(const ApplicationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationMessage& operator=(ApplicationMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplicationMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplicationMessage* internal_default_instance() {
    return reinterpret_cast<const ApplicationMessage*>(
               &_ApplicationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ApplicationMessage& a, ApplicationMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplicationMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplicationMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplicationMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplicationMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplicationMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplicationMessage& from) {
    ApplicationMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplicationMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ApplicationMessage";
  }
  protected:
  explicit ApplicationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyFieldNumber = 2,
    kSignatureFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // bytes body = 2;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // string signature = 3;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .ApplicationMessageHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::ApplicationMessageHeader& header() const;
  PROTOBUF_NODISCARD ::ApplicationMessageHeader* release_header();
  ::ApplicationMessageHeader* mutable_header();
  void set_allocated_header(::ApplicationMessageHeader* header);
  private:
  const ::ApplicationMessageHeader& _internal_header() const;
  ::ApplicationMessageHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::ApplicationMessageHeader* header);
  ::ApplicationMessageHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:ApplicationMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    ::ApplicationMessageHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class ApplicationMessageHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ApplicationMessageHeader) */ {
 public:
  inline ApplicationMessageHeader() : ApplicationMessageHeader(nullptr) {}
  ~ApplicationMessageHeader() override;
  explicit PROTOBUF_CONSTEXPR ApplicationMessageHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplicationMessageHeader(const ApplicationMessageHeader& from);
  ApplicationMessageHeader(ApplicationMessageHeader&& from) noexcept
    : ApplicationMessageHeader() {
    *this = ::std::move(from);
  }

  inline ApplicationMessageHeader& operator=(const ApplicationMessageHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationMessageHeader& operator=(ApplicationMessageHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplicationMessageHeader& default_instance() {
    return *internal_default_instance();
  }
  enum SubjectOrRecipientCase {
    kSubject = 1,
    kRecipients = 2,
    SUBJECTORRECIPIENT_NOT_SET = 0,
  };

  static inline const ApplicationMessageHeader* internal_default_instance() {
    return reinterpret_cast<const ApplicationMessageHeader*>(
               &_ApplicationMessageHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ApplicationMessageHeader& a, ApplicationMessageHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplicationMessageHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplicationMessageHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplicationMessageHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplicationMessageHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplicationMessageHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplicationMessageHeader& from) {
    ApplicationMessageHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplicationMessageHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ApplicationMessageHeader";
  }
  protected:
  explicit ApplicationMessageHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 4,
    kQosProfileFieldNumber = 5,
    kExpiresFieldNumber = 3,
    kBodySizeNumBytesFieldNumber = 6,
    kSubjectFieldNumber = 1,
    kRecipientsFieldNumber = 2,
  };
  // string sender = 4;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // optional string qosProfile = 5;
  bool has_qosprofile() const;
  private:
  bool _internal_has_qosprofile() const;
  public:
  void clear_qosprofile();
  const std::string& qosprofile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_qosprofile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_qosprofile();
  PROTOBUF_NODISCARD std::string* release_qosprofile();
  void set_allocated_qosprofile(std::string* qosprofile);
  private:
  const std::string& _internal_qosprofile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_qosprofile(const std::string& value);
  std::string* _internal_mutable_qosprofile();
  public:

  // int64 expires = 3;
  void clear_expires();
  int64_t expires() const;
  void set_expires(int64_t value);
  private:
  int64_t _internal_expires() const;
  void _internal_set_expires(int64_t value);
  public:

  // uint32 bodySizeNumBytes = 6;
  void clear_bodysizenumbytes();
  uint32_t bodysizenumbytes() const;
  void set_bodysizenumbytes(uint32_t value);
  private:
  uint32_t _internal_bodysizenumbytes() const;
  void _internal_set_bodysizenumbytes(uint32_t value);
  public:

  // string subject = 1;
  bool has_subject() const;
  private:
  bool _internal_has_subject() const;
  public:
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // .Recipients recipients = 2;
  bool has_recipients() const;
  private:
  bool _internal_has_recipients() const;
  public:
  void clear_recipients();
  const ::Recipients& recipients() const;
  PROTOBUF_NODISCARD ::Recipients* release_recipients();
  ::Recipients* mutable_recipients();
  void set_allocated_recipients(::Recipients* recipients);
  private:
  const ::Recipients& _internal_recipients() const;
  ::Recipients* _internal_mutable_recipients();
  public:
  void unsafe_arena_set_allocated_recipients(
      ::Recipients* recipients);
  ::Recipients* unsafe_arena_release_recipients();

  void clear_SubjectOrRecipient();
  SubjectOrRecipientCase SubjectOrRecipient_case() const;
  // @@protoc_insertion_point(class_scope:ApplicationMessageHeader)
 private:
  class _Internal;
  void set_has_subject();
  void set_has_recipients();

  inline bool has_SubjectOrRecipient() const;
  inline void clear_has_SubjectOrRecipient();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr qosprofile_;
    int64_t expires_;
    uint32_t bodysizenumbytes_;
    union SubjectOrRecipientUnion {
      constexpr SubjectOrRecipientUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
      ::Recipients* recipients_;
    } SubjectOrRecipient_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Recipients final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Recipients) */ {
 public:
  inline Recipients() : Recipients(nullptr) {}
  ~Recipients() override;
  explicit PROTOBUF_CONSTEXPR Recipients(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Recipients(const Recipients& from);
  Recipients(Recipients&& from) noexcept
    : Recipients() {
    *this = ::std::move(from);
  }

  inline Recipients& operator=(const Recipients& from) {
    CopyFrom(from);
    return *this;
  }
  inline Recipients& operator=(Recipients&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Recipients& default_instance() {
    return *internal_default_instance();
  }
  static inline const Recipients* internal_default_instance() {
    return reinterpret_cast<const Recipients*>(
               &_Recipients_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Recipients& a, Recipients& b) {
    a.Swap(&b);
  }
  inline void Swap(Recipients* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Recipients* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Recipients* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Recipients>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Recipients& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Recipients& from) {
    Recipients::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Recipients* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Recipients";
  }
  protected:
  explicit Recipients(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipientsFieldNumber = 1,
  };
  // repeated string recipients = 1;
  int recipients_size() const;
  private:
  int _internal_recipients_size() const;
  public:
  void clear_recipients();
  const std::string& recipients(int index) const;
  std::string* mutable_recipients(int index);
  void set_recipients(int index, const std::string& value);
  void set_recipients(int index, std::string&& value);
  void set_recipients(int index, const char* value);
  void set_recipients(int index, const char* value, size_t size);
  std::string* add_recipients();
  void add_recipients(const std::string& value);
  void add_recipients(std::string&& value);
  void add_recipients(const char* value);
  void add_recipients(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& recipients() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_recipients();
  private:
  const std::string& _internal_recipients(int index) const;
  std::string* _internal_add_recipients();
  public:

  // @@protoc_insertion_point(class_scope:Recipients)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> recipients_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class MmtpMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MmtpMessage) */ {
 public:
  inline MmtpMessage() : MmtpMessage(nullptr) {}
  ~MmtpMessage() override;
  explicit PROTOBUF_CONSTEXPR MmtpMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MmtpMessage(const MmtpMessage& from);
  MmtpMessage(MmtpMessage&& from) noexcept
    : MmtpMessage() {
    *this = ::std::move(from);
  }

  inline MmtpMessage& operator=(const MmtpMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmtpMessage& operator=(MmtpMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MmtpMessage& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kProtocolMessage = 3,
    kResponseMessage = 4,
    BODY_NOT_SET = 0,
  };

  static inline const MmtpMessage* internal_default_instance() {
    return reinterpret_cast<const MmtpMessage*>(
               &_MmtpMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MmtpMessage& a, MmtpMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MmtpMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MmtpMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MmtpMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MmtpMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MmtpMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MmtpMessage& from) {
    MmtpMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MmtpMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MmtpMessage";
  }
  protected:
  explicit MmtpMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 2,
    kMsgTypeFieldNumber = 1,
    kProtocolMessageFieldNumber = 3,
    kResponseMessageFieldNumber = 4,
  };
  // string uuid = 2;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .MsgType msgType = 1;
  void clear_msgtype();
  ::MsgType msgtype() const;
  void set_msgtype(::MsgType value);
  private:
  ::MsgType _internal_msgtype() const;
  void _internal_set_msgtype(::MsgType value);
  public:

  // .ProtocolMessage protocolMessage = 3;
  bool has_protocolmessage() const;
  private:
  bool _internal_has_protocolmessage() const;
  public:
  void clear_protocolmessage();
  const ::ProtocolMessage& protocolmessage() const;
  PROTOBUF_NODISCARD ::ProtocolMessage* release_protocolmessage();
  ::ProtocolMessage* mutable_protocolmessage();
  void set_allocated_protocolmessage(::ProtocolMessage* protocolmessage);
  private:
  const ::ProtocolMessage& _internal_protocolmessage() const;
  ::ProtocolMessage* _internal_mutable_protocolmessage();
  public:
  void unsafe_arena_set_allocated_protocolmessage(
      ::ProtocolMessage* protocolmessage);
  ::ProtocolMessage* unsafe_arena_release_protocolmessage();

  // .ResponseMessage responseMessage = 4;
  bool has_responsemessage() const;
  private:
  bool _internal_has_responsemessage() const;
  public:
  void clear_responsemessage();
  const ::ResponseMessage& responsemessage() const;
  PROTOBUF_NODISCARD ::ResponseMessage* release_responsemessage();
  ::ResponseMessage* mutable_responsemessage();
  void set_allocated_responsemessage(::ResponseMessage* responsemessage);
  private:
  const ::ResponseMessage& _internal_responsemessage() const;
  ::ResponseMessage* _internal_mutable_responsemessage();
  public:
  void unsafe_arena_set_allocated_responsemessage(
      ::ResponseMessage* responsemessage);
  ::ResponseMessage* unsafe_arena_release_responsemessage();

  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:MmtpMessage)
 private:
  class _Internal;
  void set_has_protocolmessage();
  void set_has_responsemessage();

  inline bool has_body() const;
  inline void clear_has_body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    int msgtype_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ProtocolMessage* protocolmessage_;
      ::ResponseMessage* responsemessage_;
    } body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class ProtocolMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtocolMessage) */ {
 public:
  inline ProtocolMessage() : ProtocolMessage(nullptr) {}
  ~ProtocolMessage() override;
  explicit PROTOBUF_CONSTEXPR ProtocolMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtocolMessage(const ProtocolMessage& from);
  ProtocolMessage(ProtocolMessage&& from) noexcept
    : ProtocolMessage() {
    *this = ::std::move(from);
  }

  inline ProtocolMessage& operator=(const ProtocolMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolMessage& operator=(ProtocolMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtocolMessage& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kSubscribeMessage = 2,
    kUnsubscribeMessage = 3,
    kSendMessage = 4,
    kReceiveMessage = 5,
    kFetchMessage = 6,
    kDisconnectMessage = 7,
    kConnectMessage = 8,
    BODY_NOT_SET = 0,
  };

  static inline const ProtocolMessage* internal_default_instance() {
    return reinterpret_cast<const ProtocolMessage*>(
               &_ProtocolMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ProtocolMessage& a, ProtocolMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtocolMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtocolMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtocolMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtocolMessage& from) {
    ProtocolMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtocolMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtocolMessage";
  }
  protected:
  explicit ProtocolMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolMsgTypeFieldNumber = 1,
    kSubscribeMessageFieldNumber = 2,
    kUnsubscribeMessageFieldNumber = 3,
    kSendMessageFieldNumber = 4,
    kReceiveMessageFieldNumber = 5,
    kFetchMessageFieldNumber = 6,
    kDisconnectMessageFieldNumber = 7,
    kConnectMessageFieldNumber = 8,
  };
  // .ProtocolMessageType protocolMsgType = 1;
  void clear_protocolmsgtype();
  ::ProtocolMessageType protocolmsgtype() const;
  void set_protocolmsgtype(::ProtocolMessageType value);
  private:
  ::ProtocolMessageType _internal_protocolmsgtype() const;
  void _internal_set_protocolmsgtype(::ProtocolMessageType value);
  public:

  // .Subscribe subscribeMessage = 2;
  bool has_subscribemessage() const;
  private:
  bool _internal_has_subscribemessage() const;
  public:
  void clear_subscribemessage();
  const ::Subscribe& subscribemessage() const;
  PROTOBUF_NODISCARD ::Subscribe* release_subscribemessage();
  ::Subscribe* mutable_subscribemessage();
  void set_allocated_subscribemessage(::Subscribe* subscribemessage);
  private:
  const ::Subscribe& _internal_subscribemessage() const;
  ::Subscribe* _internal_mutable_subscribemessage();
  public:
  void unsafe_arena_set_allocated_subscribemessage(
      ::Subscribe* subscribemessage);
  ::Subscribe* unsafe_arena_release_subscribemessage();

  // .Unsubscribe unsubscribeMessage = 3;
  bool has_unsubscribemessage() const;
  private:
  bool _internal_has_unsubscribemessage() const;
  public:
  void clear_unsubscribemessage();
  const ::Unsubscribe& unsubscribemessage() const;
  PROTOBUF_NODISCARD ::Unsubscribe* release_unsubscribemessage();
  ::Unsubscribe* mutable_unsubscribemessage();
  void set_allocated_unsubscribemessage(::Unsubscribe* unsubscribemessage);
  private:
  const ::Unsubscribe& _internal_unsubscribemessage() const;
  ::Unsubscribe* _internal_mutable_unsubscribemessage();
  public:
  void unsafe_arena_set_allocated_unsubscribemessage(
      ::Unsubscribe* unsubscribemessage);
  ::Unsubscribe* unsafe_arena_release_unsubscribemessage();

  // .Send sendMessage = 4;
  bool has_sendmessage() const;
  private:
  bool _internal_has_sendmessage() const;
  public:
  void clear_sendmessage();
  const ::Send& sendmessage() const;
  PROTOBUF_NODISCARD ::Send* release_sendmessage();
  ::Send* mutable_sendmessage();
  void set_allocated_sendmessage(::Send* sendmessage);
  private:
  const ::Send& _internal_sendmessage() const;
  ::Send* _internal_mutable_sendmessage();
  public:
  void unsafe_arena_set_allocated_sendmessage(
      ::Send* sendmessage);
  ::Send* unsafe_arena_release_sendmessage();

  // .Receive receiveMessage = 5;
  bool has_receivemessage() const;
  private:
  bool _internal_has_receivemessage() const;
  public:
  void clear_receivemessage();
  const ::Receive& receivemessage() const;
  PROTOBUF_NODISCARD ::Receive* release_receivemessage();
  ::Receive* mutable_receivemessage();
  void set_allocated_receivemessage(::Receive* receivemessage);
  private:
  const ::Receive& _internal_receivemessage() const;
  ::Receive* _internal_mutable_receivemessage();
  public:
  void unsafe_arena_set_allocated_receivemessage(
      ::Receive* receivemessage);
  ::Receive* unsafe_arena_release_receivemessage();

  // .Fetch fetchMessage = 6;
  bool has_fetchmessage() const;
  private:
  bool _internal_has_fetchmessage() const;
  public:
  void clear_fetchmessage();
  const ::Fetch& fetchmessage() const;
  PROTOBUF_NODISCARD ::Fetch* release_fetchmessage();
  ::Fetch* mutable_fetchmessage();
  void set_allocated_fetchmessage(::Fetch* fetchmessage);
  private:
  const ::Fetch& _internal_fetchmessage() const;
  ::Fetch* _internal_mutable_fetchmessage();
  public:
  void unsafe_arena_set_allocated_fetchmessage(
      ::Fetch* fetchmessage);
  ::Fetch* unsafe_arena_release_fetchmessage();

  // .Disconnect disconnectMessage = 7;
  bool has_disconnectmessage() const;
  private:
  bool _internal_has_disconnectmessage() const;
  public:
  void clear_disconnectmessage();
  const ::Disconnect& disconnectmessage() const;
  PROTOBUF_NODISCARD ::Disconnect* release_disconnectmessage();
  ::Disconnect* mutable_disconnectmessage();
  void set_allocated_disconnectmessage(::Disconnect* disconnectmessage);
  private:
  const ::Disconnect& _internal_disconnectmessage() const;
  ::Disconnect* _internal_mutable_disconnectmessage();
  public:
  void unsafe_arena_set_allocated_disconnectmessage(
      ::Disconnect* disconnectmessage);
  ::Disconnect* unsafe_arena_release_disconnectmessage();

  // .Connect connectMessage = 8;
  bool has_connectmessage() const;
  private:
  bool _internal_has_connectmessage() const;
  public:
  void clear_connectmessage();
  const ::Connect& connectmessage() const;
  PROTOBUF_NODISCARD ::Connect* release_connectmessage();
  ::Connect* mutable_connectmessage();
  void set_allocated_connectmessage(::Connect* connectmessage);
  private:
  const ::Connect& _internal_connectmessage() const;
  ::Connect* _internal_mutable_connectmessage();
  public:
  void unsafe_arena_set_allocated_connectmessage(
      ::Connect* connectmessage);
  ::Connect* unsafe_arena_release_connectmessage();

  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:ProtocolMessage)
 private:
  class _Internal;
  void set_has_subscribemessage();
  void set_has_unsubscribemessage();
  void set_has_sendmessage();
  void set_has_receivemessage();
  void set_has_fetchmessage();
  void set_has_disconnectmessage();
  void set_has_connectmessage();

  inline bool has_body() const;
  inline void clear_has_body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int protocolmsgtype_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Subscribe* subscribemessage_;
      ::Unsubscribe* unsubscribemessage_;
      ::Send* sendmessage_;
      ::Receive* receivemessage_;
      ::Fetch* fetchmessage_;
      ::Disconnect* disconnectmessage_;
      ::Connect* connectmessage_;
    } body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Subscribe final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Subscribe) */ {
 public:
  inline Subscribe() : Subscribe(nullptr) {}
  ~Subscribe() override;
  explicit PROTOBUF_CONSTEXPR Subscribe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subscribe(const Subscribe& from);
  Subscribe(Subscribe&& from) noexcept
    : Subscribe() {
    *this = ::std::move(from);
  }

  inline Subscribe& operator=(const Subscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscribe& operator=(Subscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subscribe& default_instance() {
    return *internal_default_instance();
  }
  enum SubjectOrDirectMessagesCase {
    kSubject = 1,
    kDirectMessages = 2,
    SUBJECTORDIRECTMESSAGES_NOT_SET = 0,
  };

  static inline const Subscribe* internal_default_instance() {
    return reinterpret_cast<const Subscribe*>(
               &_Subscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Subscribe& a, Subscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(Subscribe* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscribe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subscribe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Subscribe>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subscribe& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Subscribe& from) {
    Subscribe::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subscribe* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Subscribe";
  }
  protected:
  explicit Subscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 1,
    kDirectMessagesFieldNumber = 2,
  };
  // string subject = 1;
  bool has_subject() const;
  private:
  bool _internal_has_subject() const;
  public:
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // bool directMessages = 2;
  bool has_directmessages() const;
  private:
  bool _internal_has_directmessages() const;
  public:
  void clear_directmessages();
  bool directmessages() const;
  void set_directmessages(bool value);
  private:
  bool _internal_directmessages() const;
  void _internal_set_directmessages(bool value);
  public:

  void clear_subjectOrDirectMessages();
  SubjectOrDirectMessagesCase subjectOrDirectMessages_case() const;
  // @@protoc_insertion_point(class_scope:Subscribe)
 private:
  class _Internal;
  void set_has_subject();
  void set_has_directmessages();

  inline bool has_subjectOrDirectMessages() const;
  inline void clear_has_subjectOrDirectMessages();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union SubjectOrDirectMessagesUnion {
      constexpr SubjectOrDirectMessagesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
      bool directmessages_;
    } subjectOrDirectMessages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Unsubscribe final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Unsubscribe) */ {
 public:
  inline Unsubscribe() : Unsubscribe(nullptr) {}
  ~Unsubscribe() override;
  explicit PROTOBUF_CONSTEXPR Unsubscribe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Unsubscribe(const Unsubscribe& from);
  Unsubscribe(Unsubscribe&& from) noexcept
    : Unsubscribe() {
    *this = ::std::move(from);
  }

  inline Unsubscribe& operator=(const Unsubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline Unsubscribe& operator=(Unsubscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Unsubscribe& default_instance() {
    return *internal_default_instance();
  }
  enum SubjectOrDirectMessagesCase {
    kSubject = 1,
    kDirectMessages = 2,
    SUBJECTORDIRECTMESSAGES_NOT_SET = 0,
  };

  static inline const Unsubscribe* internal_default_instance() {
    return reinterpret_cast<const Unsubscribe*>(
               &_Unsubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Unsubscribe& a, Unsubscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(Unsubscribe* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Unsubscribe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Unsubscribe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Unsubscribe>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Unsubscribe& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Unsubscribe& from) {
    Unsubscribe::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unsubscribe* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Unsubscribe";
  }
  protected:
  explicit Unsubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 1,
    kDirectMessagesFieldNumber = 2,
  };
  // string subject = 1;
  bool has_subject() const;
  private:
  bool _internal_has_subject() const;
  public:
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // bool directMessages = 2;
  bool has_directmessages() const;
  private:
  bool _internal_has_directmessages() const;
  public:
  void clear_directmessages();
  bool directmessages() const;
  void set_directmessages(bool value);
  private:
  bool _internal_directmessages() const;
  void _internal_set_directmessages(bool value);
  public:

  void clear_subjectOrDirectMessages();
  SubjectOrDirectMessagesCase subjectOrDirectMessages_case() const;
  // @@protoc_insertion_point(class_scope:Unsubscribe)
 private:
  class _Internal;
  void set_has_subject();
  void set_has_directmessages();

  inline bool has_subjectOrDirectMessages() const;
  inline void clear_has_subjectOrDirectMessages();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union SubjectOrDirectMessagesUnion {
      constexpr SubjectOrDirectMessagesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
      bool directmessages_;
    } subjectOrDirectMessages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Send final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Send) */ {
 public:
  inline Send() : Send(nullptr) {}
  ~Send() override;
  explicit PROTOBUF_CONSTEXPR Send(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Send(const Send& from);
  Send(Send&& from) noexcept
    : Send() {
    *this = ::std::move(from);
  }

  inline Send& operator=(const Send& from) {
    CopyFrom(from);
    return *this;
  }
  inline Send& operator=(Send&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Send& default_instance() {
    return *internal_default_instance();
  }
  static inline const Send* internal_default_instance() {
    return reinterpret_cast<const Send*>(
               &_Send_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Send& a, Send& b) {
    a.Swap(&b);
  }
  inline void Swap(Send* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Send* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Send* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Send>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Send& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Send& from) {
    Send::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Send* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Send";
  }
  protected:
  explicit Send(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApplicationMessageFieldNumber = 1,
  };
  // .ApplicationMessage applicationMessage = 1;
  bool has_applicationmessage() const;
  private:
  bool _internal_has_applicationmessage() const;
  public:
  void clear_applicationmessage();
  const ::ApplicationMessage& applicationmessage() const;
  PROTOBUF_NODISCARD ::ApplicationMessage* release_applicationmessage();
  ::ApplicationMessage* mutable_applicationmessage();
  void set_allocated_applicationmessage(::ApplicationMessage* applicationmessage);
  private:
  const ::ApplicationMessage& _internal_applicationmessage() const;
  ::ApplicationMessage* _internal_mutable_applicationmessage();
  public:
  void unsafe_arena_set_allocated_applicationmessage(
      ::ApplicationMessage* applicationmessage);
  ::ApplicationMessage* unsafe_arena_release_applicationmessage();

  // @@protoc_insertion_point(class_scope:Send)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ApplicationMessage* applicationmessage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Receive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Receive) */ {
 public:
  inline Receive() : Receive(nullptr) {}
  ~Receive() override;
  explicit PROTOBUF_CONSTEXPR Receive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Receive(const Receive& from);
  Receive(Receive&& from) noexcept
    : Receive() {
    *this = ::std::move(from);
  }

  inline Receive& operator=(const Receive& from) {
    CopyFrom(from);
    return *this;
  }
  inline Receive& operator=(Receive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Receive& default_instance() {
    return *internal_default_instance();
  }
  static inline const Receive* internal_default_instance() {
    return reinterpret_cast<const Receive*>(
               &_Receive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Receive& a, Receive& b) {
    a.Swap(&b);
  }
  inline void Swap(Receive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Receive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Receive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Receive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Receive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Receive& from) {
    Receive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Receive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Receive";
  }
  protected:
  explicit Receive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // optional .Filter filter = 1;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::Filter& filter() const;
  PROTOBUF_NODISCARD ::Filter* release_filter();
  ::Filter* mutable_filter();
  void set_allocated_filter(::Filter* filter);
  private:
  const ::Filter& _internal_filter() const;
  ::Filter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::Filter* filter);
  ::Filter* unsafe_arena_release_filter();

  // @@protoc_insertion_point(class_scope:Receive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Filter* filter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Filter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Filter) */ {
 public:
  inline Filter() : Filter(nullptr) {}
  ~Filter() override;
  explicit PROTOBUF_CONSTEXPR Filter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Filter(const Filter& from);
  Filter(Filter&& from) noexcept
    : Filter() {
    *this = ::std::move(from);
  }

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
               &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Filter& a, Filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Filter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Filter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Filter& from) {
    Filter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Filter";
  }
  protected:
  explicit Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageUuidsFieldNumber = 1,
  };
  // repeated string messageUuids = 1;
  int messageuuids_size() const;
  private:
  int _internal_messageuuids_size() const;
  public:
  void clear_messageuuids();
  const std::string& messageuuids(int index) const;
  std::string* mutable_messageuuids(int index);
  void set_messageuuids(int index, const std::string& value);
  void set_messageuuids(int index, std::string&& value);
  void set_messageuuids(int index, const char* value);
  void set_messageuuids(int index, const char* value, size_t size);
  std::string* add_messageuuids();
  void add_messageuuids(const std::string& value);
  void add_messageuuids(std::string&& value);
  void add_messageuuids(const char* value);
  void add_messageuuids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& messageuuids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_messageuuids();
  private:
  const std::string& _internal_messageuuids(int index) const;
  std::string* _internal_add_messageuuids();
  public:

  // @@protoc_insertion_point(class_scope:Filter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> messageuuids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Fetch final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Fetch) */ {
 public:
  inline Fetch() : Fetch(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Fetch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fetch(const Fetch& from);
  Fetch(Fetch&& from) noexcept
    : Fetch() {
    *this = ::std::move(from);
  }

  inline Fetch& operator=(const Fetch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fetch& operator=(Fetch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fetch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fetch* internal_default_instance() {
    return reinterpret_cast<const Fetch*>(
               &_Fetch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Fetch& a, Fetch& b) {
    a.Swap(&b);
  }
  inline void Swap(Fetch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fetch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fetch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fetch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Fetch& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Fetch& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Fetch";
  }
  protected:
  explicit Fetch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Fetch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Disconnect final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Disconnect) */ {
 public:
  inline Disconnect() : Disconnect(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Disconnect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Disconnect(const Disconnect& from);
  Disconnect(Disconnect&& from) noexcept
    : Disconnect() {
    *this = ::std::move(from);
  }

  inline Disconnect& operator=(const Disconnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Disconnect& operator=(Disconnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Disconnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Disconnect* internal_default_instance() {
    return reinterpret_cast<const Disconnect*>(
               &_Disconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Disconnect& a, Disconnect& b) {
    a.Swap(&b);
  }
  inline void Swap(Disconnect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Disconnect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Disconnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Disconnect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Disconnect& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Disconnect& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Disconnect";
  }
  protected:
  explicit Disconnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Disconnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Connect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Connect) */ {
 public:
  inline Connect() : Connect(nullptr) {}
  ~Connect() override;
  explicit PROTOBUF_CONSTEXPR Connect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connect(const Connect& from);
  Connect(Connect&& from) noexcept
    : Connect() {
    *this = ::std::move(from);
  }

  inline Connect& operator=(const Connect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connect& operator=(Connect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connect* internal_default_instance() {
    return reinterpret_cast<const Connect*>(
               &_Connect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Connect& a, Connect& b) {
    a.Swap(&b);
  }
  inline void Swap(Connect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Connect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Connect& from) {
    Connect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Connect";
  }
  protected:
  explicit Connect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnMrnFieldNumber = 1,
    kReconnectTokenFieldNumber = 2,
  };
  // optional string ownMrn = 1;
  bool has_ownmrn() const;
  private:
  bool _internal_has_ownmrn() const;
  public:
  void clear_ownmrn();
  const std::string& ownmrn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownmrn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownmrn();
  PROTOBUF_NODISCARD std::string* release_ownmrn();
  void set_allocated_ownmrn(std::string* ownmrn);
  private:
  const std::string& _internal_ownmrn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownmrn(const std::string& value);
  std::string* _internal_mutable_ownmrn();
  public:

  // optional string reconnectToken = 2;
  bool has_reconnecttoken() const;
  private:
  bool _internal_has_reconnecttoken() const;
  public:
  void clear_reconnecttoken();
  const std::string& reconnecttoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reconnecttoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reconnecttoken();
  PROTOBUF_NODISCARD std::string* release_reconnecttoken();
  void set_allocated_reconnecttoken(std::string* reconnecttoken);
  private:
  const std::string& _internal_reconnecttoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reconnecttoken(const std::string& value);
  std::string* _internal_mutable_reconnecttoken();
  public:

  // @@protoc_insertion_point(class_scope:Connect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownmrn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reconnecttoken_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class ResponseMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResponseMessage) */ {
 public:
  inline ResponseMessage() : ResponseMessage(nullptr) {}
  ~ResponseMessage() override;
  explicit PROTOBUF_CONSTEXPR ResponseMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseMessage(const ResponseMessage& from);
  ResponseMessage(ResponseMessage&& from) noexcept
    : ResponseMessage() {
    *this = ::std::move(from);
  }

  inline ResponseMessage& operator=(const ResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseMessage& operator=(ResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseMessage* internal_default_instance() {
    return reinterpret_cast<const ResponseMessage*>(
               &_ResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ResponseMessage& a, ResponseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseMessage& from) {
    ResponseMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResponseMessage";
  }
  protected:
  explicit ResponseMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageMetadataFieldNumber = 4,
    kApplicationMessagesFieldNumber = 5,
    kResponseToUuidFieldNumber = 1,
    kReasonTextFieldNumber = 3,
    kReconnectTokenFieldNumber = 6,
    kResponseFieldNumber = 2,
  };
  // repeated .MessageMetadata messageMetadata = 4;
  int messagemetadata_size() const;
  private:
  int _internal_messagemetadata_size() const;
  public:
  void clear_messagemetadata();
  ::MessageMetadata* mutable_messagemetadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MessageMetadata >*
      mutable_messagemetadata();
  private:
  const ::MessageMetadata& _internal_messagemetadata(int index) const;
  ::MessageMetadata* _internal_add_messagemetadata();
  public:
  const ::MessageMetadata& messagemetadata(int index) const;
  ::MessageMetadata* add_messagemetadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MessageMetadata >&
      messagemetadata() const;

  // repeated .ApplicationMessage applicationMessages = 5;
  int applicationmessages_size() const;
  private:
  int _internal_applicationmessages_size() const;
  public:
  void clear_applicationmessages();
  ::ApplicationMessage* mutable_applicationmessages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ApplicationMessage >*
      mutable_applicationmessages();
  private:
  const ::ApplicationMessage& _internal_applicationmessages(int index) const;
  ::ApplicationMessage* _internal_add_applicationmessages();
  public:
  const ::ApplicationMessage& applicationmessages(int index) const;
  ::ApplicationMessage* add_applicationmessages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ApplicationMessage >&
      applicationmessages() const;

  // string responseToUuid = 1;
  void clear_responsetouuid();
  const std::string& responsetouuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_responsetouuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_responsetouuid();
  PROTOBUF_NODISCARD std::string* release_responsetouuid();
  void set_allocated_responsetouuid(std::string* responsetouuid);
  private:
  const std::string& _internal_responsetouuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responsetouuid(const std::string& value);
  std::string* _internal_mutable_responsetouuid();
  public:

  // optional string reasonText = 3;
  bool has_reasontext() const;
  private:
  bool _internal_has_reasontext() const;
  public:
  void clear_reasontext();
  const std::string& reasontext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reasontext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reasontext();
  PROTOBUF_NODISCARD std::string* release_reasontext();
  void set_allocated_reasontext(std::string* reasontext);
  private:
  const std::string& _internal_reasontext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reasontext(const std::string& value);
  std::string* _internal_mutable_reasontext();
  public:

  // optional string reconnectToken = 6;
  bool has_reconnecttoken() const;
  private:
  bool _internal_has_reconnecttoken() const;
  public:
  void clear_reconnecttoken();
  const std::string& reconnecttoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reconnecttoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reconnecttoken();
  PROTOBUF_NODISCARD std::string* release_reconnecttoken();
  void set_allocated_reconnecttoken(std::string* reconnecttoken);
  private:
  const std::string& _internal_reconnecttoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reconnecttoken(const std::string& value);
  std::string* _internal_mutable_reconnecttoken();
  public:

  // .ResponseEnum response = 2;
  void clear_response();
  ::ResponseEnum response() const;
  void set_response(::ResponseEnum value);
  private:
  ::ResponseEnum _internal_response() const;
  void _internal_set_response(::ResponseEnum value);
  public:

  // @@protoc_insertion_point(class_scope:ResponseMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MessageMetadata > messagemetadata_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ApplicationMessage > applicationmessages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr responsetouuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reasontext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reconnecttoken_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class MessageMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MessageMetadata) */ {
 public:
  inline MessageMetadata() : MessageMetadata(nullptr) {}
  ~MessageMetadata() override;
  explicit PROTOBUF_CONSTEXPR MessageMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageMetadata(const MessageMetadata& from);
  MessageMetadata(MessageMetadata&& from) noexcept
    : MessageMetadata() {
    *this = ::std::move(from);
  }

  inline MessageMetadata& operator=(const MessageMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageMetadata& operator=(MessageMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageMetadata* internal_default_instance() {
    return reinterpret_cast<const MessageMetadata*>(
               &_MessageMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MessageMetadata& a, MessageMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageMetadata& from) {
    MessageMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MessageMetadata";
  }
  protected:
  explicit MessageMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kHeaderFieldNumber = 2,
  };
  // string uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .ApplicationMessageHeader header = 2;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::ApplicationMessageHeader& header() const;
  PROTOBUF_NODISCARD ::ApplicationMessageHeader* release_header();
  ::ApplicationMessageHeader* mutable_header();
  void set_allocated_header(::ApplicationMessageHeader* header);
  private:
  const ::ApplicationMessageHeader& _internal_header() const;
  ::ApplicationMessageHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::ApplicationMessageHeader* header);
  ::ApplicationMessageHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:MessageMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::ApplicationMessageHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ApplicationMessage

// .ApplicationMessageHeader header = 1;
inline bool ApplicationMessage::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ApplicationMessage::has_header() const {
  return _internal_has_header();
}
inline void ApplicationMessage::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::ApplicationMessageHeader& ApplicationMessage::_internal_header() const {
  const ::ApplicationMessageHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::ApplicationMessageHeader&>(
      ::_ApplicationMessageHeader_default_instance_);
}
inline const ::ApplicationMessageHeader& ApplicationMessage::header() const {
  // @@protoc_insertion_point(field_get:ApplicationMessage.header)
  return _internal_header();
}
inline void ApplicationMessage::unsafe_arena_set_allocated_header(
    ::ApplicationMessageHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApplicationMessage.header)
}
inline ::ApplicationMessageHeader* ApplicationMessage::release_header() {
  
  ::ApplicationMessageHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ApplicationMessageHeader* ApplicationMessage::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:ApplicationMessage.header)
  
  ::ApplicationMessageHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::ApplicationMessageHeader* ApplicationMessage::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::ApplicationMessageHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::ApplicationMessageHeader* ApplicationMessage::mutable_header() {
  ::ApplicationMessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:ApplicationMessage.header)
  return _msg;
}
inline void ApplicationMessage::set_allocated_header(::ApplicationMessageHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessage.header)
}

// bytes body = 2;
inline void ApplicationMessage::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& ApplicationMessage::body() const {
  // @@protoc_insertion_point(field_get:ApplicationMessage.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplicationMessage::set_body(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ApplicationMessage.body)
}
inline std::string* ApplicationMessage::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:ApplicationMessage.body)
  return _s;
}
inline const std::string& ApplicationMessage::_internal_body() const {
  return _impl_.body_.Get();
}
inline void ApplicationMessage::_internal_set_body(const std::string& value) {
  
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplicationMessage::_internal_mutable_body() {
  
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplicationMessage::release_body() {
  // @@protoc_insertion_point(field_release:ApplicationMessage.body)
  return _impl_.body_.Release();
}
inline void ApplicationMessage::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessage.body)
}

// string signature = 3;
inline void ApplicationMessage::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& ApplicationMessage::signature() const {
  // @@protoc_insertion_point(field_get:ApplicationMessage.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplicationMessage::set_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ApplicationMessage.signature)
}
inline std::string* ApplicationMessage::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:ApplicationMessage.signature)
  return _s;
}
inline const std::string& ApplicationMessage::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void ApplicationMessage::_internal_set_signature(const std::string& value) {
  
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplicationMessage::_internal_mutable_signature() {
  
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplicationMessage::release_signature() {
  // @@protoc_insertion_point(field_release:ApplicationMessage.signature)
  return _impl_.signature_.Release();
}
inline void ApplicationMessage::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessage.signature)
}

// -------------------------------------------------------------------

// ApplicationMessageHeader

// string subject = 1;
inline bool ApplicationMessageHeader::_internal_has_subject() const {
  return SubjectOrRecipient_case() == kSubject;
}
inline bool ApplicationMessageHeader::has_subject() const {
  return _internal_has_subject();
}
inline void ApplicationMessageHeader::set_has_subject() {
  _impl_._oneof_case_[0] = kSubject;
}
inline void ApplicationMessageHeader::clear_subject() {
  if (_internal_has_subject()) {
    _impl_.SubjectOrRecipient_.subject_.Destroy();
    clear_has_SubjectOrRecipient();
  }
}
inline const std::string& ApplicationMessageHeader::subject() const {
  // @@protoc_insertion_point(field_get:ApplicationMessageHeader.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline void ApplicationMessageHeader::set_subject(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_subject()) {
    clear_SubjectOrRecipient();
    set_has_subject();
    _impl_.SubjectOrRecipient_.subject_.InitDefault();
  }
  _impl_.SubjectOrRecipient_.subject_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ApplicationMessageHeader.subject)
}
inline std::string* ApplicationMessageHeader::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:ApplicationMessageHeader.subject)
  return _s;
}
inline const std::string& ApplicationMessageHeader::_internal_subject() const {
  if (_internal_has_subject()) {
    return _impl_.SubjectOrRecipient_.subject_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ApplicationMessageHeader::_internal_set_subject(const std::string& value) {
  if (!_internal_has_subject()) {
    clear_SubjectOrRecipient();
    set_has_subject();
    _impl_.SubjectOrRecipient_.subject_.InitDefault();
  }
  _impl_.SubjectOrRecipient_.subject_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplicationMessageHeader::_internal_mutable_subject() {
  if (!_internal_has_subject()) {
    clear_SubjectOrRecipient();
    set_has_subject();
    _impl_.SubjectOrRecipient_.subject_.InitDefault();
  }
  return _impl_.SubjectOrRecipient_.subject_.Mutable(      GetArenaForAllocation());
}
inline std::string* ApplicationMessageHeader::release_subject() {
  // @@protoc_insertion_point(field_release:ApplicationMessageHeader.subject)
  if (_internal_has_subject()) {
    clear_has_SubjectOrRecipient();
    return _impl_.SubjectOrRecipient_.subject_.Release();
  } else {
    return nullptr;
  }
}
inline void ApplicationMessageHeader::set_allocated_subject(std::string* subject) {
  if (has_SubjectOrRecipient()) {
    clear_SubjectOrRecipient();
  }
  if (subject != nullptr) {
    set_has_subject();
    _impl_.SubjectOrRecipient_.subject_.InitAllocated(subject, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessageHeader.subject)
}

// .Recipients recipients = 2;
inline bool ApplicationMessageHeader::_internal_has_recipients() const {
  return SubjectOrRecipient_case() == kRecipients;
}
inline bool ApplicationMessageHeader::has_recipients() const {
  return _internal_has_recipients();
}
inline void ApplicationMessageHeader::set_has_recipients() {
  _impl_._oneof_case_[0] = kRecipients;
}
inline void ApplicationMessageHeader::clear_recipients() {
  if (_internal_has_recipients()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.SubjectOrRecipient_.recipients_;
    }
    clear_has_SubjectOrRecipient();
  }
}
inline ::Recipients* ApplicationMessageHeader::release_recipients() {
  // @@protoc_insertion_point(field_release:ApplicationMessageHeader.recipients)
  if (_internal_has_recipients()) {
    clear_has_SubjectOrRecipient();
    ::Recipients* temp = _impl_.SubjectOrRecipient_.recipients_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.SubjectOrRecipient_.recipients_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Recipients& ApplicationMessageHeader::_internal_recipients() const {
  return _internal_has_recipients()
      ? *_impl_.SubjectOrRecipient_.recipients_
      : reinterpret_cast< ::Recipients&>(::_Recipients_default_instance_);
}
inline const ::Recipients& ApplicationMessageHeader::recipients() const {
  // @@protoc_insertion_point(field_get:ApplicationMessageHeader.recipients)
  return _internal_recipients();
}
inline ::Recipients* ApplicationMessageHeader::unsafe_arena_release_recipients() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApplicationMessageHeader.recipients)
  if (_internal_has_recipients()) {
    clear_has_SubjectOrRecipient();
    ::Recipients* temp = _impl_.SubjectOrRecipient_.recipients_;
    _impl_.SubjectOrRecipient_.recipients_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApplicationMessageHeader::unsafe_arena_set_allocated_recipients(::Recipients* recipients) {
  clear_SubjectOrRecipient();
  if (recipients) {
    set_has_recipients();
    _impl_.SubjectOrRecipient_.recipients_ = recipients;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApplicationMessageHeader.recipients)
}
inline ::Recipients* ApplicationMessageHeader::_internal_mutable_recipients() {
  if (!_internal_has_recipients()) {
    clear_SubjectOrRecipient();
    set_has_recipients();
    _impl_.SubjectOrRecipient_.recipients_ = CreateMaybeMessage< ::Recipients >(GetArenaForAllocation());
  }
  return _impl_.SubjectOrRecipient_.recipients_;
}
inline ::Recipients* ApplicationMessageHeader::mutable_recipients() {
  ::Recipients* _msg = _internal_mutable_recipients();
  // @@protoc_insertion_point(field_mutable:ApplicationMessageHeader.recipients)
  return _msg;
}

// int64 expires = 3;
inline void ApplicationMessageHeader::clear_expires() {
  _impl_.expires_ = int64_t{0};
}
inline int64_t ApplicationMessageHeader::_internal_expires() const {
  return _impl_.expires_;
}
inline int64_t ApplicationMessageHeader::expires() const {
  // @@protoc_insertion_point(field_get:ApplicationMessageHeader.expires)
  return _internal_expires();
}
inline void ApplicationMessageHeader::_internal_set_expires(int64_t value) {
  
  _impl_.expires_ = value;
}
inline void ApplicationMessageHeader::set_expires(int64_t value) {
  _internal_set_expires(value);
  // @@protoc_insertion_point(field_set:ApplicationMessageHeader.expires)
}

// string sender = 4;
inline void ApplicationMessageHeader::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& ApplicationMessageHeader::sender() const {
  // @@protoc_insertion_point(field_get:ApplicationMessageHeader.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplicationMessageHeader::set_sender(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sender_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ApplicationMessageHeader.sender)
}
inline std::string* ApplicationMessageHeader::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:ApplicationMessageHeader.sender)
  return _s;
}
inline const std::string& ApplicationMessageHeader::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void ApplicationMessageHeader::_internal_set_sender(const std::string& value) {
  
  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplicationMessageHeader::_internal_mutable_sender() {
  
  return _impl_.sender_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplicationMessageHeader::release_sender() {
  // @@protoc_insertion_point(field_release:ApplicationMessageHeader.sender)
  return _impl_.sender_.Release();
}
inline void ApplicationMessageHeader::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  _impl_.sender_.SetAllocated(sender, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_.IsDefault()) {
    _impl_.sender_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessageHeader.sender)
}

// optional string qosProfile = 5;
inline bool ApplicationMessageHeader::_internal_has_qosprofile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApplicationMessageHeader::has_qosprofile() const {
  return _internal_has_qosprofile();
}
inline void ApplicationMessageHeader::clear_qosprofile() {
  _impl_.qosprofile_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApplicationMessageHeader::qosprofile() const {
  // @@protoc_insertion_point(field_get:ApplicationMessageHeader.qosProfile)
  return _internal_qosprofile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplicationMessageHeader::set_qosprofile(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.qosprofile_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ApplicationMessageHeader.qosProfile)
}
inline std::string* ApplicationMessageHeader::mutable_qosprofile() {
  std::string* _s = _internal_mutable_qosprofile();
  // @@protoc_insertion_point(field_mutable:ApplicationMessageHeader.qosProfile)
  return _s;
}
inline const std::string& ApplicationMessageHeader::_internal_qosprofile() const {
  return _impl_.qosprofile_.Get();
}
inline void ApplicationMessageHeader::_internal_set_qosprofile(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.qosprofile_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplicationMessageHeader::_internal_mutable_qosprofile() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.qosprofile_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplicationMessageHeader::release_qosprofile() {
  // @@protoc_insertion_point(field_release:ApplicationMessageHeader.qosProfile)
  if (!_internal_has_qosprofile()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.qosprofile_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.qosprofile_.IsDefault()) {
    _impl_.qosprofile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ApplicationMessageHeader::set_allocated_qosprofile(std::string* qosprofile) {
  if (qosprofile != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.qosprofile_.SetAllocated(qosprofile, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.qosprofile_.IsDefault()) {
    _impl_.qosprofile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessageHeader.qosProfile)
}

// uint32 bodySizeNumBytes = 6;
inline void ApplicationMessageHeader::clear_bodysizenumbytes() {
  _impl_.bodysizenumbytes_ = 0u;
}
inline uint32_t ApplicationMessageHeader::_internal_bodysizenumbytes() const {
  return _impl_.bodysizenumbytes_;
}
inline uint32_t ApplicationMessageHeader::bodysizenumbytes() const {
  // @@protoc_insertion_point(field_get:ApplicationMessageHeader.bodySizeNumBytes)
  return _internal_bodysizenumbytes();
}
inline void ApplicationMessageHeader::_internal_set_bodysizenumbytes(uint32_t value) {
  
  _impl_.bodysizenumbytes_ = value;
}
inline void ApplicationMessageHeader::set_bodysizenumbytes(uint32_t value) {
  _internal_set_bodysizenumbytes(value);
  // @@protoc_insertion_point(field_set:ApplicationMessageHeader.bodySizeNumBytes)
}

inline bool ApplicationMessageHeader::has_SubjectOrRecipient() const {
  return SubjectOrRecipient_case() != SUBJECTORRECIPIENT_NOT_SET;
}
inline void ApplicationMessageHeader::clear_has_SubjectOrRecipient() {
  _impl_._oneof_case_[0] = SUBJECTORRECIPIENT_NOT_SET;
}
inline ApplicationMessageHeader::SubjectOrRecipientCase ApplicationMessageHeader::SubjectOrRecipient_case() const {
  return ApplicationMessageHeader::SubjectOrRecipientCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Recipients

// repeated string recipients = 1;
inline int Recipients::_internal_recipients_size() const {
  return _impl_.recipients_.size();
}
inline int Recipients::recipients_size() const {
  return _internal_recipients_size();
}
inline void Recipients::clear_recipients() {
  _impl_.recipients_.Clear();
}
inline std::string* Recipients::add_recipients() {
  std::string* _s = _internal_add_recipients();
  // @@protoc_insertion_point(field_add_mutable:Recipients.recipients)
  return _s;
}
inline const std::string& Recipients::_internal_recipients(int index) const {
  return _impl_.recipients_.Get(index);
}
inline const std::string& Recipients::recipients(int index) const {
  // @@protoc_insertion_point(field_get:Recipients.recipients)
  return _internal_recipients(index);
}
inline std::string* Recipients::mutable_recipients(int index) {
  // @@protoc_insertion_point(field_mutable:Recipients.recipients)
  return _impl_.recipients_.Mutable(index);
}
inline void Recipients::set_recipients(int index, const std::string& value) {
  _impl_.recipients_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Recipients.recipients)
}
inline void Recipients::set_recipients(int index, std::string&& value) {
  _impl_.recipients_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Recipients.recipients)
}
inline void Recipients::set_recipients(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.recipients_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Recipients.recipients)
}
inline void Recipients::set_recipients(int index, const char* value, size_t size) {
  _impl_.recipients_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Recipients.recipients)
}
inline std::string* Recipients::_internal_add_recipients() {
  return _impl_.recipients_.Add();
}
inline void Recipients::add_recipients(const std::string& value) {
  _impl_.recipients_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Recipients.recipients)
}
inline void Recipients::add_recipients(std::string&& value) {
  _impl_.recipients_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Recipients.recipients)
}
inline void Recipients::add_recipients(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.recipients_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Recipients.recipients)
}
inline void Recipients::add_recipients(const char* value, size_t size) {
  _impl_.recipients_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Recipients.recipients)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Recipients::recipients() const {
  // @@protoc_insertion_point(field_list:Recipients.recipients)
  return _impl_.recipients_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Recipients::mutable_recipients() {
  // @@protoc_insertion_point(field_mutable_list:Recipients.recipients)
  return &_impl_.recipients_;
}

// -------------------------------------------------------------------

// MmtpMessage

// .MsgType msgType = 1;
inline void MmtpMessage::clear_msgtype() {
  _impl_.msgtype_ = 0;
}
inline ::MsgType MmtpMessage::_internal_msgtype() const {
  return static_cast< ::MsgType >(_impl_.msgtype_);
}
inline ::MsgType MmtpMessage::msgtype() const {
  // @@protoc_insertion_point(field_get:MmtpMessage.msgType)
  return _internal_msgtype();
}
inline void MmtpMessage::_internal_set_msgtype(::MsgType value) {
  
  _impl_.msgtype_ = value;
}
inline void MmtpMessage::set_msgtype(::MsgType value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:MmtpMessage.msgType)
}

// string uuid = 2;
inline void MmtpMessage::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& MmtpMessage::uuid() const {
  // @@protoc_insertion_point(field_get:MmtpMessage.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MmtpMessage::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MmtpMessage.uuid)
}
inline std::string* MmtpMessage::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:MmtpMessage.uuid)
  return _s;
}
inline const std::string& MmtpMessage::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void MmtpMessage::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* MmtpMessage::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* MmtpMessage::release_uuid() {
  // @@protoc_insertion_point(field_release:MmtpMessage.uuid)
  return _impl_.uuid_.Release();
}
inline void MmtpMessage::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MmtpMessage.uuid)
}

// .ProtocolMessage protocolMessage = 3;
inline bool MmtpMessage::_internal_has_protocolmessage() const {
  return body_case() == kProtocolMessage;
}
inline bool MmtpMessage::has_protocolmessage() const {
  return _internal_has_protocolmessage();
}
inline void MmtpMessage::set_has_protocolmessage() {
  _impl_._oneof_case_[0] = kProtocolMessage;
}
inline void MmtpMessage::clear_protocolmessage() {
  if (_internal_has_protocolmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.protocolmessage_;
    }
    clear_has_body();
  }
}
inline ::ProtocolMessage* MmtpMessage::release_protocolmessage() {
  // @@protoc_insertion_point(field_release:MmtpMessage.protocolMessage)
  if (_internal_has_protocolmessage()) {
    clear_has_body();
    ::ProtocolMessage* temp = _impl_.body_.protocolmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.protocolmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ProtocolMessage& MmtpMessage::_internal_protocolmessage() const {
  return _internal_has_protocolmessage()
      ? *_impl_.body_.protocolmessage_
      : reinterpret_cast< ::ProtocolMessage&>(::_ProtocolMessage_default_instance_);
}
inline const ::ProtocolMessage& MmtpMessage::protocolmessage() const {
  // @@protoc_insertion_point(field_get:MmtpMessage.protocolMessage)
  return _internal_protocolmessage();
}
inline ::ProtocolMessage* MmtpMessage::unsafe_arena_release_protocolmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MmtpMessage.protocolMessage)
  if (_internal_has_protocolmessage()) {
    clear_has_body();
    ::ProtocolMessage* temp = _impl_.body_.protocolmessage_;
    _impl_.body_.protocolmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MmtpMessage::unsafe_arena_set_allocated_protocolmessage(::ProtocolMessage* protocolmessage) {
  clear_body();
  if (protocolmessage) {
    set_has_protocolmessage();
    _impl_.body_.protocolmessage_ = protocolmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MmtpMessage.protocolMessage)
}
inline ::ProtocolMessage* MmtpMessage::_internal_mutable_protocolmessage() {
  if (!_internal_has_protocolmessage()) {
    clear_body();
    set_has_protocolmessage();
    _impl_.body_.protocolmessage_ = CreateMaybeMessage< ::ProtocolMessage >(GetArenaForAllocation());
  }
  return _impl_.body_.protocolmessage_;
}
inline ::ProtocolMessage* MmtpMessage::mutable_protocolmessage() {
  ::ProtocolMessage* _msg = _internal_mutable_protocolmessage();
  // @@protoc_insertion_point(field_mutable:MmtpMessage.protocolMessage)
  return _msg;
}

// .ResponseMessage responseMessage = 4;
inline bool MmtpMessage::_internal_has_responsemessage() const {
  return body_case() == kResponseMessage;
}
inline bool MmtpMessage::has_responsemessage() const {
  return _internal_has_responsemessage();
}
inline void MmtpMessage::set_has_responsemessage() {
  _impl_._oneof_case_[0] = kResponseMessage;
}
inline void MmtpMessage::clear_responsemessage() {
  if (_internal_has_responsemessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.responsemessage_;
    }
    clear_has_body();
  }
}
inline ::ResponseMessage* MmtpMessage::release_responsemessage() {
  // @@protoc_insertion_point(field_release:MmtpMessage.responseMessage)
  if (_internal_has_responsemessage()) {
    clear_has_body();
    ::ResponseMessage* temp = _impl_.body_.responsemessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.responsemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ResponseMessage& MmtpMessage::_internal_responsemessage() const {
  return _internal_has_responsemessage()
      ? *_impl_.body_.responsemessage_
      : reinterpret_cast< ::ResponseMessage&>(::_ResponseMessage_default_instance_);
}
inline const ::ResponseMessage& MmtpMessage::responsemessage() const {
  // @@protoc_insertion_point(field_get:MmtpMessage.responseMessage)
  return _internal_responsemessage();
}
inline ::ResponseMessage* MmtpMessage::unsafe_arena_release_responsemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MmtpMessage.responseMessage)
  if (_internal_has_responsemessage()) {
    clear_has_body();
    ::ResponseMessage* temp = _impl_.body_.responsemessage_;
    _impl_.body_.responsemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MmtpMessage::unsafe_arena_set_allocated_responsemessage(::ResponseMessage* responsemessage) {
  clear_body();
  if (responsemessage) {
    set_has_responsemessage();
    _impl_.body_.responsemessage_ = responsemessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MmtpMessage.responseMessage)
}
inline ::ResponseMessage* MmtpMessage::_internal_mutable_responsemessage() {
  if (!_internal_has_responsemessage()) {
    clear_body();
    set_has_responsemessage();
    _impl_.body_.responsemessage_ = CreateMaybeMessage< ::ResponseMessage >(GetArenaForAllocation());
  }
  return _impl_.body_.responsemessage_;
}
inline ::ResponseMessage* MmtpMessage::mutable_responsemessage() {
  ::ResponseMessage* _msg = _internal_mutable_responsemessage();
  // @@protoc_insertion_point(field_mutable:MmtpMessage.responseMessage)
  return _msg;
}

inline bool MmtpMessage::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void MmtpMessage::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline MmtpMessage::BodyCase MmtpMessage::body_case() const {
  return MmtpMessage::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProtocolMessage

// .ProtocolMessageType protocolMsgType = 1;
inline void ProtocolMessage::clear_protocolmsgtype() {
  _impl_.protocolmsgtype_ = 0;
}
inline ::ProtocolMessageType ProtocolMessage::_internal_protocolmsgtype() const {
  return static_cast< ::ProtocolMessageType >(_impl_.protocolmsgtype_);
}
inline ::ProtocolMessageType ProtocolMessage::protocolmsgtype() const {
  // @@protoc_insertion_point(field_get:ProtocolMessage.protocolMsgType)
  return _internal_protocolmsgtype();
}
inline void ProtocolMessage::_internal_set_protocolmsgtype(::ProtocolMessageType value) {
  
  _impl_.protocolmsgtype_ = value;
}
inline void ProtocolMessage::set_protocolmsgtype(::ProtocolMessageType value) {
  _internal_set_protocolmsgtype(value);
  // @@protoc_insertion_point(field_set:ProtocolMessage.protocolMsgType)
}

// .Subscribe subscribeMessage = 2;
inline bool ProtocolMessage::_internal_has_subscribemessage() const {
  return body_case() == kSubscribeMessage;
}
inline bool ProtocolMessage::has_subscribemessage() const {
  return _internal_has_subscribemessage();
}
inline void ProtocolMessage::set_has_subscribemessage() {
  _impl_._oneof_case_[0] = kSubscribeMessage;
}
inline void ProtocolMessage::clear_subscribemessage() {
  if (_internal_has_subscribemessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.subscribemessage_;
    }
    clear_has_body();
  }
}
inline ::Subscribe* ProtocolMessage::release_subscribemessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.subscribeMessage)
  if (_internal_has_subscribemessage()) {
    clear_has_body();
    ::Subscribe* temp = _impl_.body_.subscribemessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.subscribemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Subscribe& ProtocolMessage::_internal_subscribemessage() const {
  return _internal_has_subscribemessage()
      ? *_impl_.body_.subscribemessage_
      : reinterpret_cast< ::Subscribe&>(::_Subscribe_default_instance_);
}
inline const ::Subscribe& ProtocolMessage::subscribemessage() const {
  // @@protoc_insertion_point(field_get:ProtocolMessage.subscribeMessage)
  return _internal_subscribemessage();
}
inline ::Subscribe* ProtocolMessage::unsafe_arena_release_subscribemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.subscribeMessage)
  if (_internal_has_subscribemessage()) {
    clear_has_body();
    ::Subscribe* temp = _impl_.body_.subscribemessage_;
    _impl_.body_.subscribemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_subscribemessage(::Subscribe* subscribemessage) {
  clear_body();
  if (subscribemessage) {
    set_has_subscribemessage();
    _impl_.body_.subscribemessage_ = subscribemessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.subscribeMessage)
}
inline ::Subscribe* ProtocolMessage::_internal_mutable_subscribemessage() {
  if (!_internal_has_subscribemessage()) {
    clear_body();
    set_has_subscribemessage();
    _impl_.body_.subscribemessage_ = CreateMaybeMessage< ::Subscribe >(GetArenaForAllocation());
  }
  return _impl_.body_.subscribemessage_;
}
inline ::Subscribe* ProtocolMessage::mutable_subscribemessage() {
  ::Subscribe* _msg = _internal_mutable_subscribemessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.subscribeMessage)
  return _msg;
}

// .Unsubscribe unsubscribeMessage = 3;
inline bool ProtocolMessage::_internal_has_unsubscribemessage() const {
  return body_case() == kUnsubscribeMessage;
}
inline bool ProtocolMessage::has_unsubscribemessage() const {
  return _internal_has_unsubscribemessage();
}
inline void ProtocolMessage::set_has_unsubscribemessage() {
  _impl_._oneof_case_[0] = kUnsubscribeMessage;
}
inline void ProtocolMessage::clear_unsubscribemessage() {
  if (_internal_has_unsubscribemessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.unsubscribemessage_;
    }
    clear_has_body();
  }
}
inline ::Unsubscribe* ProtocolMessage::release_unsubscribemessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.unsubscribeMessage)
  if (_internal_has_unsubscribemessage()) {
    clear_has_body();
    ::Unsubscribe* temp = _impl_.body_.unsubscribemessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.unsubscribemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Unsubscribe& ProtocolMessage::_internal_unsubscribemessage() const {
  return _internal_has_unsubscribemessage()
      ? *_impl_.body_.unsubscribemessage_
      : reinterpret_cast< ::Unsubscribe&>(::_Unsubscribe_default_instance_);
}
inline const ::Unsubscribe& ProtocolMessage::unsubscribemessage() const {
  // @@protoc_insertion_point(field_get:ProtocolMessage.unsubscribeMessage)
  return _internal_unsubscribemessage();
}
inline ::Unsubscribe* ProtocolMessage::unsafe_arena_release_unsubscribemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.unsubscribeMessage)
  if (_internal_has_unsubscribemessage()) {
    clear_has_body();
    ::Unsubscribe* temp = _impl_.body_.unsubscribemessage_;
    _impl_.body_.unsubscribemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_unsubscribemessage(::Unsubscribe* unsubscribemessage) {
  clear_body();
  if (unsubscribemessage) {
    set_has_unsubscribemessage();
    _impl_.body_.unsubscribemessage_ = unsubscribemessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.unsubscribeMessage)
}
inline ::Unsubscribe* ProtocolMessage::_internal_mutable_unsubscribemessage() {
  if (!_internal_has_unsubscribemessage()) {
    clear_body();
    set_has_unsubscribemessage();
    _impl_.body_.unsubscribemessage_ = CreateMaybeMessage< ::Unsubscribe >(GetArenaForAllocation());
  }
  return _impl_.body_.unsubscribemessage_;
}
inline ::Unsubscribe* ProtocolMessage::mutable_unsubscribemessage() {
  ::Unsubscribe* _msg = _internal_mutable_unsubscribemessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.unsubscribeMessage)
  return _msg;
}

// .Send sendMessage = 4;
inline bool ProtocolMessage::_internal_has_sendmessage() const {
  return body_case() == kSendMessage;
}
inline bool ProtocolMessage::has_sendmessage() const {
  return _internal_has_sendmessage();
}
inline void ProtocolMessage::set_has_sendmessage() {
  _impl_._oneof_case_[0] = kSendMessage;
}
inline void ProtocolMessage::clear_sendmessage() {
  if (_internal_has_sendmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.sendmessage_;
    }
    clear_has_body();
  }
}
inline ::Send* ProtocolMessage::release_sendmessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.sendMessage)
  if (_internal_has_sendmessage()) {
    clear_has_body();
    ::Send* temp = _impl_.body_.sendmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.sendmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Send& ProtocolMessage::_internal_sendmessage() const {
  return _internal_has_sendmessage()
      ? *_impl_.body_.sendmessage_
      : reinterpret_cast< ::Send&>(::_Send_default_instance_);
}
inline const ::Send& ProtocolMessage::sendmessage() const {
  // @@protoc_insertion_point(field_get:ProtocolMessage.sendMessage)
  return _internal_sendmessage();
}
inline ::Send* ProtocolMessage::unsafe_arena_release_sendmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.sendMessage)
  if (_internal_has_sendmessage()) {
    clear_has_body();
    ::Send* temp = _impl_.body_.sendmessage_;
    _impl_.body_.sendmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_sendmessage(::Send* sendmessage) {
  clear_body();
  if (sendmessage) {
    set_has_sendmessage();
    _impl_.body_.sendmessage_ = sendmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.sendMessage)
}
inline ::Send* ProtocolMessage::_internal_mutable_sendmessage() {
  if (!_internal_has_sendmessage()) {
    clear_body();
    set_has_sendmessage();
    _impl_.body_.sendmessage_ = CreateMaybeMessage< ::Send >(GetArenaForAllocation());
  }
  return _impl_.body_.sendmessage_;
}
inline ::Send* ProtocolMessage::mutable_sendmessage() {
  ::Send* _msg = _internal_mutable_sendmessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.sendMessage)
  return _msg;
}

// .Receive receiveMessage = 5;
inline bool ProtocolMessage::_internal_has_receivemessage() const {
  return body_case() == kReceiveMessage;
}
inline bool ProtocolMessage::has_receivemessage() const {
  return _internal_has_receivemessage();
}
inline void ProtocolMessage::set_has_receivemessage() {
  _impl_._oneof_case_[0] = kReceiveMessage;
}
inline void ProtocolMessage::clear_receivemessage() {
  if (_internal_has_receivemessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.receivemessage_;
    }
    clear_has_body();
  }
}
inline ::Receive* ProtocolMessage::release_receivemessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.receiveMessage)
  if (_internal_has_receivemessage()) {
    clear_has_body();
    ::Receive* temp = _impl_.body_.receivemessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.receivemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Receive& ProtocolMessage::_internal_receivemessage() const {
  return _internal_has_receivemessage()
      ? *_impl_.body_.receivemessage_
      : reinterpret_cast< ::Receive&>(::_Receive_default_instance_);
}
inline const ::Receive& ProtocolMessage::receivemessage() const {
  // @@protoc_insertion_point(field_get:ProtocolMessage.receiveMessage)
  return _internal_receivemessage();
}
inline ::Receive* ProtocolMessage::unsafe_arena_release_receivemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.receiveMessage)
  if (_internal_has_receivemessage()) {
    clear_has_body();
    ::Receive* temp = _impl_.body_.receivemessage_;
    _impl_.body_.receivemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_receivemessage(::Receive* receivemessage) {
  clear_body();
  if (receivemessage) {
    set_has_receivemessage();
    _impl_.body_.receivemessage_ = receivemessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.receiveMessage)
}
inline ::Receive* ProtocolMessage::_internal_mutable_receivemessage() {
  if (!_internal_has_receivemessage()) {
    clear_body();
    set_has_receivemessage();
    _impl_.body_.receivemessage_ = CreateMaybeMessage< ::Receive >(GetArenaForAllocation());
  }
  return _impl_.body_.receivemessage_;
}
inline ::Receive* ProtocolMessage::mutable_receivemessage() {
  ::Receive* _msg = _internal_mutable_receivemessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.receiveMessage)
  return _msg;
}

// .Fetch fetchMessage = 6;
inline bool ProtocolMessage::_internal_has_fetchmessage() const {
  return body_case() == kFetchMessage;
}
inline bool ProtocolMessage::has_fetchmessage() const {
  return _internal_has_fetchmessage();
}
inline void ProtocolMessage::set_has_fetchmessage() {
  _impl_._oneof_case_[0] = kFetchMessage;
}
inline void ProtocolMessage::clear_fetchmessage() {
  if (_internal_has_fetchmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.fetchmessage_;
    }
    clear_has_body();
  }
}
inline ::Fetch* ProtocolMessage::release_fetchmessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.fetchMessage)
  if (_internal_has_fetchmessage()) {
    clear_has_body();
    ::Fetch* temp = _impl_.body_.fetchmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.fetchmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Fetch& ProtocolMessage::_internal_fetchmessage() const {
  return _internal_has_fetchmessage()
      ? *_impl_.body_.fetchmessage_
      : reinterpret_cast< ::Fetch&>(::_Fetch_default_instance_);
}
inline const ::Fetch& ProtocolMessage::fetchmessage() const {
  // @@protoc_insertion_point(field_get:ProtocolMessage.fetchMessage)
  return _internal_fetchmessage();
}
inline ::Fetch* ProtocolMessage::unsafe_arena_release_fetchmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.fetchMessage)
  if (_internal_has_fetchmessage()) {
    clear_has_body();
    ::Fetch* temp = _impl_.body_.fetchmessage_;
    _impl_.body_.fetchmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_fetchmessage(::Fetch* fetchmessage) {
  clear_body();
  if (fetchmessage) {
    set_has_fetchmessage();
    _impl_.body_.fetchmessage_ = fetchmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.fetchMessage)
}
inline ::Fetch* ProtocolMessage::_internal_mutable_fetchmessage() {
  if (!_internal_has_fetchmessage()) {
    clear_body();
    set_has_fetchmessage();
    _impl_.body_.fetchmessage_ = CreateMaybeMessage< ::Fetch >(GetArenaForAllocation());
  }
  return _impl_.body_.fetchmessage_;
}
inline ::Fetch* ProtocolMessage::mutable_fetchmessage() {
  ::Fetch* _msg = _internal_mutable_fetchmessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.fetchMessage)
  return _msg;
}

// .Disconnect disconnectMessage = 7;
inline bool ProtocolMessage::_internal_has_disconnectmessage() const {
  return body_case() == kDisconnectMessage;
}
inline bool ProtocolMessage::has_disconnectmessage() const {
  return _internal_has_disconnectmessage();
}
inline void ProtocolMessage::set_has_disconnectmessage() {
  _impl_._oneof_case_[0] = kDisconnectMessage;
}
inline void ProtocolMessage::clear_disconnectmessage() {
  if (_internal_has_disconnectmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.disconnectmessage_;
    }
    clear_has_body();
  }
}
inline ::Disconnect* ProtocolMessage::release_disconnectmessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.disconnectMessage)
  if (_internal_has_disconnectmessage()) {
    clear_has_body();
    ::Disconnect* temp = _impl_.body_.disconnectmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.disconnectmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Disconnect& ProtocolMessage::_internal_disconnectmessage() const {
  return _internal_has_disconnectmessage()
      ? *_impl_.body_.disconnectmessage_
      : reinterpret_cast< ::Disconnect&>(::_Disconnect_default_instance_);
}
inline const ::Disconnect& ProtocolMessage::disconnectmessage() const {
  // @@protoc_insertion_point(field_get:ProtocolMessage.disconnectMessage)
  return _internal_disconnectmessage();
}
inline ::Disconnect* ProtocolMessage::unsafe_arena_release_disconnectmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.disconnectMessage)
  if (_internal_has_disconnectmessage()) {
    clear_has_body();
    ::Disconnect* temp = _impl_.body_.disconnectmessage_;
    _impl_.body_.disconnectmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_disconnectmessage(::Disconnect* disconnectmessage) {
  clear_body();
  if (disconnectmessage) {
    set_has_disconnectmessage();
    _impl_.body_.disconnectmessage_ = disconnectmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.disconnectMessage)
}
inline ::Disconnect* ProtocolMessage::_internal_mutable_disconnectmessage() {
  if (!_internal_has_disconnectmessage()) {
    clear_body();
    set_has_disconnectmessage();
    _impl_.body_.disconnectmessage_ = CreateMaybeMessage< ::Disconnect >(GetArenaForAllocation());
  }
  return _impl_.body_.disconnectmessage_;
}
inline ::Disconnect* ProtocolMessage::mutable_disconnectmessage() {
  ::Disconnect* _msg = _internal_mutable_disconnectmessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.disconnectMessage)
  return _msg;
}

// .Connect connectMessage = 8;
inline bool ProtocolMessage::_internal_has_connectmessage() const {
  return body_case() == kConnectMessage;
}
inline bool ProtocolMessage::has_connectmessage() const {
  return _internal_has_connectmessage();
}
inline void ProtocolMessage::set_has_connectmessage() {
  _impl_._oneof_case_[0] = kConnectMessage;
}
inline void ProtocolMessage::clear_connectmessage() {
  if (_internal_has_connectmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.connectmessage_;
    }
    clear_has_body();
  }
}
inline ::Connect* ProtocolMessage::release_connectmessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.connectMessage)
  if (_internal_has_connectmessage()) {
    clear_has_body();
    ::Connect* temp = _impl_.body_.connectmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.connectmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Connect& ProtocolMessage::_internal_connectmessage() const {
  return _internal_has_connectmessage()
      ? *_impl_.body_.connectmessage_
      : reinterpret_cast< ::Connect&>(::_Connect_default_instance_);
}
inline const ::Connect& ProtocolMessage::connectmessage() const {
  // @@protoc_insertion_point(field_get:ProtocolMessage.connectMessage)
  return _internal_connectmessage();
}
inline ::Connect* ProtocolMessage::unsafe_arena_release_connectmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.connectMessage)
  if (_internal_has_connectmessage()) {
    clear_has_body();
    ::Connect* temp = _impl_.body_.connectmessage_;
    _impl_.body_.connectmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_connectmessage(::Connect* connectmessage) {
  clear_body();
  if (connectmessage) {
    set_has_connectmessage();
    _impl_.body_.connectmessage_ = connectmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.connectMessage)
}
inline ::Connect* ProtocolMessage::_internal_mutable_connectmessage() {
  if (!_internal_has_connectmessage()) {
    clear_body();
    set_has_connectmessage();
    _impl_.body_.connectmessage_ = CreateMaybeMessage< ::Connect >(GetArenaForAllocation());
  }
  return _impl_.body_.connectmessage_;
}
inline ::Connect* ProtocolMessage::mutable_connectmessage() {
  ::Connect* _msg = _internal_mutable_connectmessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.connectMessage)
  return _msg;
}

inline bool ProtocolMessage::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void ProtocolMessage::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline ProtocolMessage::BodyCase ProtocolMessage::body_case() const {
  return ProtocolMessage::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Subscribe

// string subject = 1;
inline bool Subscribe::_internal_has_subject() const {
  return subjectOrDirectMessages_case() == kSubject;
}
inline bool Subscribe::has_subject() const {
  return _internal_has_subject();
}
inline void Subscribe::set_has_subject() {
  _impl_._oneof_case_[0] = kSubject;
}
inline void Subscribe::clear_subject() {
  if (_internal_has_subject()) {
    _impl_.subjectOrDirectMessages_.subject_.Destroy();
    clear_has_subjectOrDirectMessages();
  }
}
inline const std::string& Subscribe::subject() const {
  // @@protoc_insertion_point(field_get:Subscribe.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline void Subscribe::set_subject(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_subject()) {
    clear_subjectOrDirectMessages();
    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitDefault();
  }
  _impl_.subjectOrDirectMessages_.subject_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Subscribe.subject)
}
inline std::string* Subscribe::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:Subscribe.subject)
  return _s;
}
inline const std::string& Subscribe::_internal_subject() const {
  if (_internal_has_subject()) {
    return _impl_.subjectOrDirectMessages_.subject_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Subscribe::_internal_set_subject(const std::string& value) {
  if (!_internal_has_subject()) {
    clear_subjectOrDirectMessages();
    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitDefault();
  }
  _impl_.subjectOrDirectMessages_.subject_.Set(value, GetArenaForAllocation());
}
inline std::string* Subscribe::_internal_mutable_subject() {
  if (!_internal_has_subject()) {
    clear_subjectOrDirectMessages();
    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitDefault();
  }
  return _impl_.subjectOrDirectMessages_.subject_.Mutable(      GetArenaForAllocation());
}
inline std::string* Subscribe::release_subject() {
  // @@protoc_insertion_point(field_release:Subscribe.subject)
  if (_internal_has_subject()) {
    clear_has_subjectOrDirectMessages();
    return _impl_.subjectOrDirectMessages_.subject_.Release();
  } else {
    return nullptr;
  }
}
inline void Subscribe::set_allocated_subject(std::string* subject) {
  if (has_subjectOrDirectMessages()) {
    clear_subjectOrDirectMessages();
  }
  if (subject != nullptr) {
    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitAllocated(subject, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:Subscribe.subject)
}

// bool directMessages = 2;
inline bool Subscribe::_internal_has_directmessages() const {
  return subjectOrDirectMessages_case() == kDirectMessages;
}
inline bool Subscribe::has_directmessages() const {
  return _internal_has_directmessages();
}
inline void Subscribe::set_has_directmessages() {
  _impl_._oneof_case_[0] = kDirectMessages;
}
inline void Subscribe::clear_directmessages() {
  if (_internal_has_directmessages()) {
    _impl_.subjectOrDirectMessages_.directmessages_ = false;
    clear_has_subjectOrDirectMessages();
  }
}
inline bool Subscribe::_internal_directmessages() const {
  if (_internal_has_directmessages()) {
    return _impl_.subjectOrDirectMessages_.directmessages_;
  }
  return false;
}
inline void Subscribe::_internal_set_directmessages(bool value) {
  if (!_internal_has_directmessages()) {
    clear_subjectOrDirectMessages();
    set_has_directmessages();
  }
  _impl_.subjectOrDirectMessages_.directmessages_ = value;
}
inline bool Subscribe::directmessages() const {
  // @@protoc_insertion_point(field_get:Subscribe.directMessages)
  return _internal_directmessages();
}
inline void Subscribe::set_directmessages(bool value) {
  _internal_set_directmessages(value);
  // @@protoc_insertion_point(field_set:Subscribe.directMessages)
}

inline bool Subscribe::has_subjectOrDirectMessages() const {
  return subjectOrDirectMessages_case() != SUBJECTORDIRECTMESSAGES_NOT_SET;
}
inline void Subscribe::clear_has_subjectOrDirectMessages() {
  _impl_._oneof_case_[0] = SUBJECTORDIRECTMESSAGES_NOT_SET;
}
inline Subscribe::SubjectOrDirectMessagesCase Subscribe::subjectOrDirectMessages_case() const {
  return Subscribe::SubjectOrDirectMessagesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Unsubscribe

// string subject = 1;
inline bool Unsubscribe::_internal_has_subject() const {
  return subjectOrDirectMessages_case() == kSubject;
}
inline bool Unsubscribe::has_subject() const {
  return _internal_has_subject();
}
inline void Unsubscribe::set_has_subject() {
  _impl_._oneof_case_[0] = kSubject;
}
inline void Unsubscribe::clear_subject() {
  if (_internal_has_subject()) {
    _impl_.subjectOrDirectMessages_.subject_.Destroy();
    clear_has_subjectOrDirectMessages();
  }
}
inline const std::string& Unsubscribe::subject() const {
  // @@protoc_insertion_point(field_get:Unsubscribe.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline void Unsubscribe::set_subject(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_subject()) {
    clear_subjectOrDirectMessages();
    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitDefault();
  }
  _impl_.subjectOrDirectMessages_.subject_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Unsubscribe.subject)
}
inline std::string* Unsubscribe::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:Unsubscribe.subject)
  return _s;
}
inline const std::string& Unsubscribe::_internal_subject() const {
  if (_internal_has_subject()) {
    return _impl_.subjectOrDirectMessages_.subject_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Unsubscribe::_internal_set_subject(const std::string& value) {
  if (!_internal_has_subject()) {
    clear_subjectOrDirectMessages();
    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitDefault();
  }
  _impl_.subjectOrDirectMessages_.subject_.Set(value, GetArenaForAllocation());
}
inline std::string* Unsubscribe::_internal_mutable_subject() {
  if (!_internal_has_subject()) {
    clear_subjectOrDirectMessages();
    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitDefault();
  }
  return _impl_.subjectOrDirectMessages_.subject_.Mutable(      GetArenaForAllocation());
}
inline std::string* Unsubscribe::release_subject() {
  // @@protoc_insertion_point(field_release:Unsubscribe.subject)
  if (_internal_has_subject()) {
    clear_has_subjectOrDirectMessages();
    return _impl_.subjectOrDirectMessages_.subject_.Release();
  } else {
    return nullptr;
  }
}
inline void Unsubscribe::set_allocated_subject(std::string* subject) {
  if (has_subjectOrDirectMessages()) {
    clear_subjectOrDirectMessages();
  }
  if (subject != nullptr) {
    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitAllocated(subject, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:Unsubscribe.subject)
}

// bool directMessages = 2;
inline bool Unsubscribe::_internal_has_directmessages() const {
  return subjectOrDirectMessages_case() == kDirectMessages;
}
inline bool Unsubscribe::has_directmessages() const {
  return _internal_has_directmessages();
}
inline void Unsubscribe::set_has_directmessages() {
  _impl_._oneof_case_[0] = kDirectMessages;
}
inline void Unsubscribe::clear_directmessages() {
  if (_internal_has_directmessages()) {
    _impl_.subjectOrDirectMessages_.directmessages_ = false;
    clear_has_subjectOrDirectMessages();
  }
}
inline bool Unsubscribe::_internal_directmessages() const {
  if (_internal_has_directmessages()) {
    return _impl_.subjectOrDirectMessages_.directmessages_;
  }
  return false;
}
inline void Unsubscribe::_internal_set_directmessages(bool value) {
  if (!_internal_has_directmessages()) {
    clear_subjectOrDirectMessages();
    set_has_directmessages();
  }
  _impl_.subjectOrDirectMessages_.directmessages_ = value;
}
inline bool Unsubscribe::directmessages() const {
  // @@protoc_insertion_point(field_get:Unsubscribe.directMessages)
  return _internal_directmessages();
}
inline void Unsubscribe::set_directmessages(bool value) {
  _internal_set_directmessages(value);
  // @@protoc_insertion_point(field_set:Unsubscribe.directMessages)
}

inline bool Unsubscribe::has_subjectOrDirectMessages() const {
  return subjectOrDirectMessages_case() != SUBJECTORDIRECTMESSAGES_NOT_SET;
}
inline void Unsubscribe::clear_has_subjectOrDirectMessages() {
  _impl_._oneof_case_[0] = SUBJECTORDIRECTMESSAGES_NOT_SET;
}
inline Unsubscribe::SubjectOrDirectMessagesCase Unsubscribe::subjectOrDirectMessages_case() const {
  return Unsubscribe::SubjectOrDirectMessagesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Send

// .ApplicationMessage applicationMessage = 1;
inline bool Send::_internal_has_applicationmessage() const {
  return this != internal_default_instance() && _impl_.applicationmessage_ != nullptr;
}
inline bool Send::has_applicationmessage() const {
  return _internal_has_applicationmessage();
}
inline void Send::clear_applicationmessage() {
  if (GetArenaForAllocation() == nullptr && _impl_.applicationmessage_ != nullptr) {
    delete _impl_.applicationmessage_;
  }
  _impl_.applicationmessage_ = nullptr;
}
inline const ::ApplicationMessage& Send::_internal_applicationmessage() const {
  const ::ApplicationMessage* p = _impl_.applicationmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::ApplicationMessage&>(
      ::_ApplicationMessage_default_instance_);
}
inline const ::ApplicationMessage& Send::applicationmessage() const {
  // @@protoc_insertion_point(field_get:Send.applicationMessage)
  return _internal_applicationmessage();
}
inline void Send::unsafe_arena_set_allocated_applicationmessage(
    ::ApplicationMessage* applicationmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.applicationmessage_);
  }
  _impl_.applicationmessage_ = applicationmessage;
  if (applicationmessage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Send.applicationMessage)
}
inline ::ApplicationMessage* Send::release_applicationmessage() {
  
  ::ApplicationMessage* temp = _impl_.applicationmessage_;
  _impl_.applicationmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ApplicationMessage* Send::unsafe_arena_release_applicationmessage() {
  // @@protoc_insertion_point(field_release:Send.applicationMessage)
  
  ::ApplicationMessage* temp = _impl_.applicationmessage_;
  _impl_.applicationmessage_ = nullptr;
  return temp;
}
inline ::ApplicationMessage* Send::_internal_mutable_applicationmessage() {
  
  if (_impl_.applicationmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ApplicationMessage>(GetArenaForAllocation());
    _impl_.applicationmessage_ = p;
  }
  return _impl_.applicationmessage_;
}
inline ::ApplicationMessage* Send::mutable_applicationmessage() {
  ::ApplicationMessage* _msg = _internal_mutable_applicationmessage();
  // @@protoc_insertion_point(field_mutable:Send.applicationMessage)
  return _msg;
}
inline void Send::set_allocated_applicationmessage(::ApplicationMessage* applicationmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.applicationmessage_;
  }
  if (applicationmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(applicationmessage);
    if (message_arena != submessage_arena) {
      applicationmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, applicationmessage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.applicationmessage_ = applicationmessage;
  // @@protoc_insertion_point(field_set_allocated:Send.applicationMessage)
}

// -------------------------------------------------------------------

// Receive

// optional .Filter filter = 1;
inline bool Receive::_internal_has_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline bool Receive::has_filter() const {
  return _internal_has_filter();
}
inline void Receive::clear_filter() {
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Filter& Receive::_internal_filter() const {
  const ::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::Filter&>(
      ::_Filter_default_instance_);
}
inline const ::Filter& Receive::filter() const {
  // @@protoc_insertion_point(field_get:Receive.filter)
  return _internal_filter();
}
inline void Receive::unsafe_arena_set_allocated_filter(
    ::Filter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Receive.filter)
}
inline ::Filter* Receive::release_filter() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Filter* Receive::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:Receive.filter)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::Filter* Receive::_internal_mutable_filter() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::Filter>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::Filter* Receive::mutable_filter() {
  ::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:Receive.filter)
  return _msg;
}
inline void Receive::set_allocated_filter(::Filter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:Receive.filter)
}

// -------------------------------------------------------------------

// Filter

// repeated string messageUuids = 1;
inline int Filter::_internal_messageuuids_size() const {
  return _impl_.messageuuids_.size();
}
inline int Filter::messageuuids_size() const {
  return _internal_messageuuids_size();
}
inline void Filter::clear_messageuuids() {
  _impl_.messageuuids_.Clear();
}
inline std::string* Filter::add_messageuuids() {
  std::string* _s = _internal_add_messageuuids();
  // @@protoc_insertion_point(field_add_mutable:Filter.messageUuids)
  return _s;
}
inline const std::string& Filter::_internal_messageuuids(int index) const {
  return _impl_.messageuuids_.Get(index);
}
inline const std::string& Filter::messageuuids(int index) const {
  // @@protoc_insertion_point(field_get:Filter.messageUuids)
  return _internal_messageuuids(index);
}
inline std::string* Filter::mutable_messageuuids(int index) {
  // @@protoc_insertion_point(field_mutable:Filter.messageUuids)
  return _impl_.messageuuids_.Mutable(index);
}
inline void Filter::set_messageuuids(int index, const std::string& value) {
  _impl_.messageuuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Filter.messageUuids)
}
inline void Filter::set_messageuuids(int index, std::string&& value) {
  _impl_.messageuuids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Filter.messageUuids)
}
inline void Filter::set_messageuuids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.messageuuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Filter.messageUuids)
}
inline void Filter::set_messageuuids(int index, const char* value, size_t size) {
  _impl_.messageuuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Filter.messageUuids)
}
inline std::string* Filter::_internal_add_messageuuids() {
  return _impl_.messageuuids_.Add();
}
inline void Filter::add_messageuuids(const std::string& value) {
  _impl_.messageuuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Filter.messageUuids)
}
inline void Filter::add_messageuuids(std::string&& value) {
  _impl_.messageuuids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Filter.messageUuids)
}
inline void Filter::add_messageuuids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.messageuuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Filter.messageUuids)
}
inline void Filter::add_messageuuids(const char* value, size_t size) {
  _impl_.messageuuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Filter.messageUuids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Filter::messageuuids() const {
  // @@protoc_insertion_point(field_list:Filter.messageUuids)
  return _impl_.messageuuids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Filter::mutable_messageuuids() {
  // @@protoc_insertion_point(field_mutable_list:Filter.messageUuids)
  return &_impl_.messageuuids_;
}

// -------------------------------------------------------------------

// Fetch

// -------------------------------------------------------------------

// Disconnect

// -------------------------------------------------------------------

// Connect

// optional string ownMrn = 1;
inline bool Connect::_internal_has_ownmrn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Connect::has_ownmrn() const {
  return _internal_has_ownmrn();
}
inline void Connect::clear_ownmrn() {
  _impl_.ownmrn_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Connect::ownmrn() const {
  // @@protoc_insertion_point(field_get:Connect.ownMrn)
  return _internal_ownmrn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connect::set_ownmrn(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ownmrn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Connect.ownMrn)
}
inline std::string* Connect::mutable_ownmrn() {
  std::string* _s = _internal_mutable_ownmrn();
  // @@protoc_insertion_point(field_mutable:Connect.ownMrn)
  return _s;
}
inline const std::string& Connect::_internal_ownmrn() const {
  return _impl_.ownmrn_.Get();
}
inline void Connect::_internal_set_ownmrn(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ownmrn_.Set(value, GetArenaForAllocation());
}
inline std::string* Connect::_internal_mutable_ownmrn() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ownmrn_.Mutable(GetArenaForAllocation());
}
inline std::string* Connect::release_ownmrn() {
  // @@protoc_insertion_point(field_release:Connect.ownMrn)
  if (!_internal_has_ownmrn()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ownmrn_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownmrn_.IsDefault()) {
    _impl_.ownmrn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Connect::set_allocated_ownmrn(std::string* ownmrn) {
  if (ownmrn != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ownmrn_.SetAllocated(ownmrn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownmrn_.IsDefault()) {
    _impl_.ownmrn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Connect.ownMrn)
}

// optional string reconnectToken = 2;
inline bool Connect::_internal_has_reconnecttoken() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Connect::has_reconnecttoken() const {
  return _internal_has_reconnecttoken();
}
inline void Connect::clear_reconnecttoken() {
  _impl_.reconnecttoken_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Connect::reconnecttoken() const {
  // @@protoc_insertion_point(field_get:Connect.reconnectToken)
  return _internal_reconnecttoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connect::set_reconnecttoken(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.reconnecttoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Connect.reconnectToken)
}
inline std::string* Connect::mutable_reconnecttoken() {
  std::string* _s = _internal_mutable_reconnecttoken();
  // @@protoc_insertion_point(field_mutable:Connect.reconnectToken)
  return _s;
}
inline const std::string& Connect::_internal_reconnecttoken() const {
  return _impl_.reconnecttoken_.Get();
}
inline void Connect::_internal_set_reconnecttoken(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.reconnecttoken_.Set(value, GetArenaForAllocation());
}
inline std::string* Connect::_internal_mutable_reconnecttoken() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.reconnecttoken_.Mutable(GetArenaForAllocation());
}
inline std::string* Connect::release_reconnecttoken() {
  // @@protoc_insertion_point(field_release:Connect.reconnectToken)
  if (!_internal_has_reconnecttoken()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.reconnecttoken_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reconnecttoken_.IsDefault()) {
    _impl_.reconnecttoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Connect::set_allocated_reconnecttoken(std::string* reconnecttoken) {
  if (reconnecttoken != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.reconnecttoken_.SetAllocated(reconnecttoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reconnecttoken_.IsDefault()) {
    _impl_.reconnecttoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Connect.reconnectToken)
}

// -------------------------------------------------------------------

// ResponseMessage

// string responseToUuid = 1;
inline void ResponseMessage::clear_responsetouuid() {
  _impl_.responsetouuid_.ClearToEmpty();
}
inline const std::string& ResponseMessage::responsetouuid() const {
  // @@protoc_insertion_point(field_get:ResponseMessage.responseToUuid)
  return _internal_responsetouuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseMessage::set_responsetouuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.responsetouuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResponseMessage.responseToUuid)
}
inline std::string* ResponseMessage::mutable_responsetouuid() {
  std::string* _s = _internal_mutable_responsetouuid();
  // @@protoc_insertion_point(field_mutable:ResponseMessage.responseToUuid)
  return _s;
}
inline const std::string& ResponseMessage::_internal_responsetouuid() const {
  return _impl_.responsetouuid_.Get();
}
inline void ResponseMessage::_internal_set_responsetouuid(const std::string& value) {
  
  _impl_.responsetouuid_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseMessage::_internal_mutable_responsetouuid() {
  
  return _impl_.responsetouuid_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseMessage::release_responsetouuid() {
  // @@protoc_insertion_point(field_release:ResponseMessage.responseToUuid)
  return _impl_.responsetouuid_.Release();
}
inline void ResponseMessage::set_allocated_responsetouuid(std::string* responsetouuid) {
  if (responsetouuid != nullptr) {
    
  } else {
    
  }
  _impl_.responsetouuid_.SetAllocated(responsetouuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.responsetouuid_.IsDefault()) {
    _impl_.responsetouuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResponseMessage.responseToUuid)
}

// .ResponseEnum response = 2;
inline void ResponseMessage::clear_response() {
  _impl_.response_ = 0;
}
inline ::ResponseEnum ResponseMessage::_internal_response() const {
  return static_cast< ::ResponseEnum >(_impl_.response_);
}
inline ::ResponseEnum ResponseMessage::response() const {
  // @@protoc_insertion_point(field_get:ResponseMessage.response)
  return _internal_response();
}
inline void ResponseMessage::_internal_set_response(::ResponseEnum value) {
  
  _impl_.response_ = value;
}
inline void ResponseMessage::set_response(::ResponseEnum value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:ResponseMessage.response)
}

// optional string reasonText = 3;
inline bool ResponseMessage::_internal_has_reasontext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseMessage::has_reasontext() const {
  return _internal_has_reasontext();
}
inline void ResponseMessage::clear_reasontext() {
  _impl_.reasontext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseMessage::reasontext() const {
  // @@protoc_insertion_point(field_get:ResponseMessage.reasonText)
  return _internal_reasontext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseMessage::set_reasontext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.reasontext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResponseMessage.reasonText)
}
inline std::string* ResponseMessage::mutable_reasontext() {
  std::string* _s = _internal_mutable_reasontext();
  // @@protoc_insertion_point(field_mutable:ResponseMessage.reasonText)
  return _s;
}
inline const std::string& ResponseMessage::_internal_reasontext() const {
  return _impl_.reasontext_.Get();
}
inline void ResponseMessage::_internal_set_reasontext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reasontext_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseMessage::_internal_mutable_reasontext() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reasontext_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseMessage::release_reasontext() {
  // @@protoc_insertion_point(field_release:ResponseMessage.reasonText)
  if (!_internal_has_reasontext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.reasontext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reasontext_.IsDefault()) {
    _impl_.reasontext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseMessage::set_allocated_reasontext(std::string* reasontext) {
  if (reasontext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reasontext_.SetAllocated(reasontext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reasontext_.IsDefault()) {
    _impl_.reasontext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResponseMessage.reasonText)
}

// repeated .MessageMetadata messageMetadata = 4;
inline int ResponseMessage::_internal_messagemetadata_size() const {
  return _impl_.messagemetadata_.size();
}
inline int ResponseMessage::messagemetadata_size() const {
  return _internal_messagemetadata_size();
}
inline void ResponseMessage::clear_messagemetadata() {
  _impl_.messagemetadata_.Clear();
}
inline ::MessageMetadata* ResponseMessage::mutable_messagemetadata(int index) {
  // @@protoc_insertion_point(field_mutable:ResponseMessage.messageMetadata)
  return _impl_.messagemetadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MessageMetadata >*
ResponseMessage::mutable_messagemetadata() {
  // @@protoc_insertion_point(field_mutable_list:ResponseMessage.messageMetadata)
  return &_impl_.messagemetadata_;
}
inline const ::MessageMetadata& ResponseMessage::_internal_messagemetadata(int index) const {
  return _impl_.messagemetadata_.Get(index);
}
inline const ::MessageMetadata& ResponseMessage::messagemetadata(int index) const {
  // @@protoc_insertion_point(field_get:ResponseMessage.messageMetadata)
  return _internal_messagemetadata(index);
}
inline ::MessageMetadata* ResponseMessage::_internal_add_messagemetadata() {
  return _impl_.messagemetadata_.Add();
}
inline ::MessageMetadata* ResponseMessage::add_messagemetadata() {
  ::MessageMetadata* _add = _internal_add_messagemetadata();
  // @@protoc_insertion_point(field_add:ResponseMessage.messageMetadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MessageMetadata >&
ResponseMessage::messagemetadata() const {
  // @@protoc_insertion_point(field_list:ResponseMessage.messageMetadata)
  return _impl_.messagemetadata_;
}

// repeated .ApplicationMessage applicationMessages = 5;
inline int ResponseMessage::_internal_applicationmessages_size() const {
  return _impl_.applicationmessages_.size();
}
inline int ResponseMessage::applicationmessages_size() const {
  return _internal_applicationmessages_size();
}
inline void ResponseMessage::clear_applicationmessages() {
  _impl_.applicationmessages_.Clear();
}
inline ::ApplicationMessage* ResponseMessage::mutable_applicationmessages(int index) {
  // @@protoc_insertion_point(field_mutable:ResponseMessage.applicationMessages)
  return _impl_.applicationmessages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ApplicationMessage >*
ResponseMessage::mutable_applicationmessages() {
  // @@protoc_insertion_point(field_mutable_list:ResponseMessage.applicationMessages)
  return &_impl_.applicationmessages_;
}
inline const ::ApplicationMessage& ResponseMessage::_internal_applicationmessages(int index) const {
  return _impl_.applicationmessages_.Get(index);
}
inline const ::ApplicationMessage& ResponseMessage::applicationmessages(int index) const {
  // @@protoc_insertion_point(field_get:ResponseMessage.applicationMessages)
  return _internal_applicationmessages(index);
}
inline ::ApplicationMessage* ResponseMessage::_internal_add_applicationmessages() {
  return _impl_.applicationmessages_.Add();
}
inline ::ApplicationMessage* ResponseMessage::add_applicationmessages() {
  ::ApplicationMessage* _add = _internal_add_applicationmessages();
  // @@protoc_insertion_point(field_add:ResponseMessage.applicationMessages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ApplicationMessage >&
ResponseMessage::applicationmessages() const {
  // @@protoc_insertion_point(field_list:ResponseMessage.applicationMessages)
  return _impl_.applicationmessages_;
}

// optional string reconnectToken = 6;
inline bool ResponseMessage::_internal_has_reconnecttoken() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseMessage::has_reconnecttoken() const {
  return _internal_has_reconnecttoken();
}
inline void ResponseMessage::clear_reconnecttoken() {
  _impl_.reconnecttoken_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResponseMessage::reconnecttoken() const {
  // @@protoc_insertion_point(field_get:ResponseMessage.reconnectToken)
  return _internal_reconnecttoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseMessage::set_reconnecttoken(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.reconnecttoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResponseMessage.reconnectToken)
}
inline std::string* ResponseMessage::mutable_reconnecttoken() {
  std::string* _s = _internal_mutable_reconnecttoken();
  // @@protoc_insertion_point(field_mutable:ResponseMessage.reconnectToken)
  return _s;
}
inline const std::string& ResponseMessage::_internal_reconnecttoken() const {
  return _impl_.reconnecttoken_.Get();
}
inline void ResponseMessage::_internal_set_reconnecttoken(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.reconnecttoken_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseMessage::_internal_mutable_reconnecttoken() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.reconnecttoken_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseMessage::release_reconnecttoken() {
  // @@protoc_insertion_point(field_release:ResponseMessage.reconnectToken)
  if (!_internal_has_reconnecttoken()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.reconnecttoken_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reconnecttoken_.IsDefault()) {
    _impl_.reconnecttoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseMessage::set_allocated_reconnecttoken(std::string* reconnecttoken) {
  if (reconnecttoken != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.reconnecttoken_.SetAllocated(reconnecttoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reconnecttoken_.IsDefault()) {
    _impl_.reconnecttoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResponseMessage.reconnectToken)
}

// -------------------------------------------------------------------

// MessageMetadata

// string uuid = 1;
inline void MessageMetadata::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& MessageMetadata::uuid() const {
  // @@protoc_insertion_point(field_get:MessageMetadata.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageMetadata::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MessageMetadata.uuid)
}
inline std::string* MessageMetadata::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:MessageMetadata.uuid)
  return _s;
}
inline const std::string& MessageMetadata::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void MessageMetadata::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageMetadata::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageMetadata::release_uuid() {
  // @@protoc_insertion_point(field_release:MessageMetadata.uuid)
  return _impl_.uuid_.Release();
}
inline void MessageMetadata::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MessageMetadata.uuid)
}

// .ApplicationMessageHeader header = 2;
inline bool MessageMetadata::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool MessageMetadata::has_header() const {
  return _internal_has_header();
}
inline void MessageMetadata::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::ApplicationMessageHeader& MessageMetadata::_internal_header() const {
  const ::ApplicationMessageHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::ApplicationMessageHeader&>(
      ::_ApplicationMessageHeader_default_instance_);
}
inline const ::ApplicationMessageHeader& MessageMetadata::header() const {
  // @@protoc_insertion_point(field_get:MessageMetadata.header)
  return _internal_header();
}
inline void MessageMetadata::unsafe_arena_set_allocated_header(
    ::ApplicationMessageHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageMetadata.header)
}
inline ::ApplicationMessageHeader* MessageMetadata::release_header() {
  
  ::ApplicationMessageHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ApplicationMessageHeader* MessageMetadata::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:MessageMetadata.header)
  
  ::ApplicationMessageHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::ApplicationMessageHeader* MessageMetadata::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::ApplicationMessageHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::ApplicationMessageHeader* MessageMetadata::mutable_header() {
  ::ApplicationMessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:MessageMetadata.header)
  return _msg;
}
inline void MessageMetadata::set_allocated_header(::ApplicationMessageHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:MessageMetadata.header)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgType>() {
  return ::MsgType_descriptor();
}
template <> struct is_proto_enum< ::ProtocolMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtocolMessageType>() {
  return ::ProtocolMessageType_descriptor();
}
template <> struct is_proto_enum< ::ResponseEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ResponseEnum>() {
  return ::ResponseEnum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mmtp_2eproto
